<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realistic Black Hole Prototype</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #info {
            position: absolute; top: 10px; left: 10px; color: rgba(255,255,255,0.8);
            background: rgba(0,0,0,0.5); padding: 15px; border-radius: 8px;
            pointer-events: none; border: 1px solid rgba(255,255,255,0.2);
            z-index: 100;
        }
        h1 { margin: 0 0 5px 0; font-size: 18px; color: #ff9d00; }
        p { margin: 0; font-size: 12px; }
    </style>
</head>
<body>
    <div id="info">
        <h1>Hybrid Ray-Marching Engine</h1>
        <p>Real Relativistic Physics Applied:</p>
        <p>- Pure Mathematical Light Bending</p>
        <p>- 3D Volumetric Particle Swarm</p>
        <p>- Event Horizon Shadow Occlusion</p>
        <p>- Raytraced Environment</p>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.156.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.156.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- 1. CORE SETUP ---
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 8, 35);

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2; 
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 10;
        controls.maxDistance = 90;

        // --- 2. HYBRID SCENE ARCHITECTURE ---
        const sceneRaymarch = new THREE.Scene();  // For the curved spacetime quad
        const sceneParticles = new THREE.Scene(); // For the rasterized 3D particles

        const orthoCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        // --- 3. LAYER 1: GENERAL RELATIVITY RAYMARCHER ---
        const raymarchVertexShader = `
            varying vec2 vUv;
            void main() { vUv = uv; gl_Position = vec4(position, 1.0); }
        `;

        const raymarchFragmentShader = `
            uniform vec3 uCameraPos;
            uniform mat4 uCameraMatrix;
            uniform vec2 uResolution;
            uniform float uTime;
            uniform float uSpinSpeed;
            uniform float uRadiusLimit;
            uniform float uDiskBrightness;
            uniform float uLensStrength;

            varying vec2 vUv;

            float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
            float noise(vec2 st) {
                vec2 i = floor(st); vec2 f = fract(st);
                float a = random(i); float b = random(i + vec2(1.0, 0.0));
                float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0));
                vec2 u = f * f * (3.0 - 2.0 * f);
                return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
            }
            float fbm(vec2 st) {
                float value = 0.0; float amp = 0.5;
                for (int i = 0; i < 4; i++) {
                    value += amp * noise(st); st *= 2.0; amp *= 0.5;
                }
                return value;
            }

            void main() {
                vec2 uv = (vUv - 0.5) * 2.0;
                uv.x *= uResolution.x / uResolution.y;

                float fov = tan(45.0 * 0.5 * 3.14159 / 180.0);
                vec3 rayDir = normalize(vec3(uv.x * fov, uv.y * fov, -1.0));
                rayDir = (uCameraMatrix * vec4(rayDir, 0.0)).xyz;
                
                vec3 rayPos = uCameraPos;
                
                float rs = uRadiusLimit;
                vec3 h = cross(rayPos, rayDir);
                float h2 = dot(h, h);
                
                vec4 color = vec4(0.0);
                float dt = 0.05;
                bool hitHorizon = false;
                
                for(int i = 0; i < 200; i++) {
                    float r2 = dot(rayPos, rayPos);
                    float r = sqrt(r2);
                    
                    if(r < rs * 0.98) { hitHorizon = true; break; }
                    if(r > 150.0) { break; }
                    
                    vec3 accel = -1.5 * uLensStrength * h2 * rs * rayPos / (r2 * r2 * r);
                    rayDir = normalize(rayDir + accel * dt);
                    
                    float r_xz = length(rayPos.xz);
                    
                    // CRITICAL FIX: Add the ISCO (Innermost Stable Circular Orbit) gap
                    float isco = rs * 1.35;
                    
                    if(r_xz > isco && r_xz < 28.0) {
                        float scaleHeight = 0.03 * rs + pow(max(0.0, r_xz - isco)/15.0, 2.0) * 0.25;
                        float yDist = abs(rayPos.y);
                        float verticalFade = exp(-yDist * yDist / (scaleHeight * scaleHeight));
                        
                        if(verticalFade > 0.01) {
                            float omega = (2.0 * uSpinSpeed) * pow(isco / r_xz, 0.65);
                            float angle = atan(rayPos.z, rayPos.x) + uTime * omega;
                            
                            vec2 p2 = vec2(cos(angle)*r_xz, sin(angle)*r_xz) * 0.4;
                            vec2 w = vec2(fbm(p2 + vec2(2.1, 5.7)), fbm(p2 + vec2(8.3, 1.3)));
                            float gas = fbm(p2 * 1.5 + w * 2.0 - uTime * 0.15);
                            
                            float isInner = 1.0 - smoothstep(isco, isco + 1.5, r_xz);
                            float density = mix(smoothstep(0.2, 0.8, gas), 1.0, isInner) * verticalFade;
                            density *= 1.0 - smoothstep(18.0, 28.0, r_xz); 
                            
                            float temp = pow(isco / r_xz, 1.4);
                            vec3 c = mix(vec3(0.6, 0.05, 0.0), vec3(1.0, 0.4, 0.0), smoothstep(0.0, 0.3, temp));
                            c = mix(c, vec3(1.0, 0.85, 0.3), smoothstep(0.3, 0.7, temp));
                            c = mix(c, vec3(1.0, 1.0, 1.0), smoothstep(0.7, 1.0, temp));
                            
                            vec3 velDir = normalize(vec3(-rayPos.z, 0.0, rayPos.x));
                            float doppler = dot(-rayDir, velDir); 
                            
                            // CRITICAL FIX: Tone down the explosive relativistic math to stop the right side from blowing out
                            float beaming = 1.0 + doppler * 0.8; 
                            
                            vec3 em = c * beaming * uDiskBrightness * density;
                            float alpha = density * dt * 3.5;
                            
                            color.rgb += (1.0 - color.a) * em * dt;
                            color.a += (1.0 - color.a) * alpha;
                            
                            if(color.a > 0.99) break;
                        }
                    }
                    
                    dt = 0.04 * r;
                    float distToEquator = abs(rayPos.y);
                    if(distToEquator < 1.0 && r_xz < 30.0) {
                        dt = min(dt, max(0.015, distToEquator * 0.3));
                    }
                    if (rayPos.y * (rayPos.y + rayDir.y * dt) < 0.0) {
                        dt = min(dt, abs(rayPos.y / rayDir.y) + 0.001); 
                    }
                    rayPos += rayDir * dt;
                }
                
                if(!hitHorizon && color.a < 0.99) {
                    vec3 absDir = abs(rayDir);
                    float maxAxis = max(max(absDir.x, absDir.y), absDir.z);
                    vec3 boxPos = rayDir / maxAxis * 100.0;
                    
                    vec2 uvBox;
                    if(maxAxis == absDir.y) uvBox = boxPos.xz;
                    else if(maxAxis == absDir.x) uvBox = boxPos.yz;
                    else uvBox = boxPos.xy;
                    
                    vec2 grid = fract(uvBox * 0.15);
                    float line = step(0.96, grid.x) + step(0.96, grid.y);
                    vec3 roomCol = mix(vec3(0.015, 0.015, 0.02), vec3(0.0), clamp(line, 0.0, 1.0));
                    
                    float dist = length(boxPos);
                    roomCol += vec3(1.0, 0.5, 0.1) * (150.0 * rs / (dist * dist)); 
                    
                    color.rgb += (1.0 - color.a) * roomCol;
                }
                
                gl_FragColor = vec4(color.rgb, 1.0);
            }
        `;

        const raymarchMat = new THREE.ShaderMaterial({
            uniforms: {
                uCameraPos: { value: new THREE.Vector3() },
                uCameraMatrix: { value: new THREE.Matrix4() },
                uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                uTime: { value: 0 },
                uSpinSpeed: { value: 1.0 },
                uRadiusLimit: { value: 5.0 },
                uDiskBrightness: { value: 3.0 },
                uLensStrength: { value: 0.5 }
            },
            vertexShader: raymarchVertexShader,
            fragmentShader: raymarchFragmentShader,
            depthWrite: false
        });

        const quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), raymarchMat);
        sceneRaymarch.add(quad);


        // --- 4. LAYER 2: 3D VOLUMETRIC PARTICLES ---
        const particleCount = 60000; 
        const particlePositions = new Float32Array(particleCount * 3);
        const particleAngles = new Float32Array(particleCount);
        const particleRadii = new Float32Array(particleCount);
        const particleSizes = new Float32Array(particleCount);

        for (let i = 0; i < particleCount; i++) {
            // Push particles mostly to the outer edges to create a massive atmosphere
            const r = 8.0 + Math.pow(Math.random(), 1.5) * 22.0;
            const theta = Math.random() * Math.PI * 2;
            
            particleRadii[i] = r;
            particleAngles[i] = theta;
            particleSizes[i] = (Math.random() * 1.5 + 0.5) * (r / 10.0); 

            particlePositions[i * 3] = r * Math.cos(theta);
            const verticalSpread = Math.pow(Math.max(0.0, r - 3.0) / 15.0, 2.0) * 2.2; 
            particlePositions[i * 3 + 1] = (Math.random() - 0.5) * verticalSpread; 
            particlePositions[i * 3 + 2] = r * Math.sin(theta);
        }

        const particleGeo = new THREE.BufferGeometry();
        particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        particleGeo.setAttribute('aAngle', new THREE.BufferAttribute(particleAngles, 1));
        particleGeo.setAttribute('aRadius', new THREE.BufferAttribute(particleRadii, 1));
        particleGeo.setAttribute('aSize', new THREE.BufferAttribute(particleSizes, 1));

        const particleVertexShader = `
            uniform float uTime;
            uniform float uSpinSpeed;
            uniform vec3 uCameraPos;
            
            attribute float aAngle;
            attribute float aRadius;
            attribute float aSize;
            
            varying float vDoppler;
            varying float vRadius;
            varying vec3 vWorldPosition;

            void main() {
                vRadius = aRadius;
                float speed = 18.0 / sqrt(aRadius);
                float currentAngle = aAngle + (uTime * speed * uSpinSpeed);
                
                vec3 newPos = position;
                newPos.x = aRadius * cos(currentAngle);
                newPos.z = aRadius * sin(currentAngle);
                newPos.y += sin(uTime * 1.5 + aAngle * 10.0) * 0.25; // Turbulent bobbing

                vec4 worldPos = modelMatrix * vec4(newPos, 1.0);
                vWorldPosition = worldPos.xyz;

                vec3 velocityDir = normalize(vec3(-sin(currentAngle), 0.0, cos(currentAngle)));
                vec3 viewDir = normalize(uCameraPos - worldPos.xyz);
                vDoppler = dot(velocityDir, viewDir);

                vec4 mvPosition = viewMatrix * worldPos;
                gl_PointSize = (aSize * 100.0) / -mvPosition.z;
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const particleFragmentShader = `
            uniform float uRadiusLimit;
            uniform vec3 uCameraPos;
            uniform float uParticleBrightness;
            
            varying float vDoppler;
            varying float vRadius;
            varying vec3 vWorldPosition;

            void main() {
                // OCCLUSION HACK: Mathematically hide particles that fall behind the black hole shadow
                vec3 toParticle = vWorldPosition - uCameraPos;
                float distToParticle = length(toParticle);
                vec3 rayDir = toParticle / distToParticle;

                // The visual shadow of a black hole is ~2.5x larger than its physical radius
                float shadowRadius = uRadiusLimit * 2.5; 
                float b = dot(uCameraPos, rayDir);
                float c = dot(uCameraPos, uCameraPos) - shadowRadius * shadowRadius;
                float d = b * b - c;

                if (d > 0.0) {
                    float t = -b - sqrt(d);
                    if (t > 0.0 && t < distToParticle) {
                        discard; // Particle is hidden behind the void!
                    }
                }

                // Soft Cloud Texture
                vec2 coord = gl_PointCoord - vec2(0.5);
                float dist = length(coord);
                if (dist > 0.5) discard;
                float alpha = exp(-dist * dist * 12.0) * 0.15; 
                
                float isco = uRadiusLimit * 1.35;
                float effR = max(vRadius, isco);
                float temp = pow(isco / effR, 1.8); 
                vec3 color = mix(vec3(0.6, 0.1, 0.0), vec3(1.0, 0.5, 0.1), smoothstep(0.0, 0.4, temp));
                color = mix(color, vec3(1.0, 0.9, 0.8), smoothstep(0.4, 1.0, temp));

                // Match the new balanced beaming from the raymarcher
                float beaming = 1.0 + vDoppler * 0.8;
                float edgeFade = 1.0 - smoothstep(15.0, 28.0, vRadius);

                gl_FragColor = vec4(color * beaming * uParticleBrightness, alpha * edgeFade);
            }
        `;

        const particleMat = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uSpinSpeed: { value: 1.0 },
                uCameraPos: { value: camera.position },
                uRadiusLimit: { value: 5.0 },
                uParticleBrightness: { value: 2.0 }
            },
            vertexShader: particleVertexShader, fragmentShader: particleFragmentShader,
            transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
        });
        
        const particles = new THREE.Points(particleGeo, particleMat);
        sceneParticles.add(particles);


        // --- 5. PIPELINE ---
        const composer = new EffectComposer(renderer);
        
        // Pass 1: Draw the heavily mathematical curved spacetime background
        const bgPass = new RenderPass(sceneRaymarch, orthoCamera);
        bgPass.clearColor = new THREE.Color(0x000000);
        bgPass.clearAlpha = 1.0;
        composer.addPass(bgPass);

        // Pass 2: Overlay the 3D particles on top (Without clearing the background!)
        const pPass = new RenderPass(sceneParticles, camera);
        pPass.clear = false;
        composer.addPass(pPass);

        // Pass 3: Cinematic Bloom
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.8, 0.5, 0.85);
        bloomPass.threshold = 0.2;
        composer.addPass(bloomPass);

        // --- 6. CONTROLS & RENDER LOOP ---
        const gui = new GUI({ title: 'Black Hole Physics' });
        const params = {
            spinSpeed: 0.1,
            lensStrength: 0.5,
            diskBrightness: 3.0,
            particleBrightness: 3.0,
            showParticles: true,
            radius: 5.0,
            autoOrbit: false,
            expand: () => triggerExpansion()
        };
        gui.add(params, 'spinSpeed', 0.0, 2.0).name('Time Scale');
        gui.add(params, 'lensStrength', 0.0, 3.5).name('Lensing Strength');
        gui.add(params, 'diskBrightness', 0.0, 15.0).name('Core Brightness');
        gui.add(params, 'particleBrightness', 0.0, 6.0).name('Gas Brightness');
        gui.add(params, 'showParticles').name('Show Particles').onChange((enabled) => {
            pPass.enabled = enabled;
        });
        gui.add(params, 'radius', 1.0, 8.0).name('Black Hole Mass').listen();
        gui.add(params, 'autoOrbit').name('Auto Camera Orbit');
        gui.add(params, 'expand').name('Simulate Growth');

        let isExpanding = false;
        let expansionTime = 0;
        let currentScale = 1.0;

        function triggerExpansion() {
            if(isExpanding) return;
            isExpanding = true;
            expansionTime = 0;
            currentScale = 0.1;
        }

        const clock = new THREE.Clock();
        const cameraMat = new THREE.Matrix4();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            if (params.autoOrbit) {
                // Slowly pan the camera around the black hole automatically
                camera.position.x = Math.cos(time * 0.1) * 35;
                camera.position.z = Math.sin(time * 0.1) * 35;
                camera.lookAt(0, 0, 0);
            }
            controls.update();

            cameraMat.extractRotation(camera.matrixWorld);
            
            raymarchMat.uniforms.uCameraPos.value.copy(camera.position);
            raymarchMat.uniforms.uCameraMatrix.value.copy(cameraMat);
            raymarchMat.uniforms.uTime.value = time;
            raymarchMat.uniforms.uSpinSpeed.value = params.spinSpeed;
            raymarchMat.uniforms.uDiskBrightness.value = params.diskBrightness;
            raymarchMat.uniforms.uLensStrength.value = params.lensStrength;

            particleMat.uniforms.uCameraPos.value.copy(camera.position);
            particleMat.uniforms.uTime.value = time;
            particleMat.uniforms.uSpinSpeed.value = params.spinSpeed;
            particleMat.uniforms.uParticleBrightness.value = params.particleBrightness;

            if (isExpanding) {
                expansionTime += delta;
                const progress = Math.min(expansionTime / 3.0, 1.0);
                const easeOut = 1 - Math.pow(1 - progress, 3);
                currentScale = 0.1 + (easeOut * 0.9); 
                params.radius = 3.0 * currentScale; // Updates UI
                if (progress >= 1.0) isExpanding = false;
            }

            raymarchMat.uniforms.uRadiusLimit.value = params.radius;
            particleMat.uniforms.uRadiusLimit.value = params.radius;

            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            raymarchMat.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
