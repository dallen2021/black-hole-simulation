<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realistic Black Hole Prototype</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #info {
            position: absolute; top: 10px; left: 10px; color: rgba(255,255,255,0.8);
            background: rgba(0,0,0,0.5); padding: 15px; border-radius: 8px;
            pointer-events: none; border: 1px solid rgba(255,255,255,0.2);
            z-index: 100;
        }
        h1 { margin: 0 0 5px 0; font-size: 18px; color: #ff9d00; }
        p { margin: 0; font-size: 12px; }
    </style>
</head>
<body>
    <div id="info">
        <h1>Hybrid Ray-Marching Engine</h1>
        <p>Real Relativistic Physics Applied:</p>
        <p>- Pure Mathematical Light Bending</p>
        <p>- 3D Volumetric Particle Swarm</p>
        <p>- Event Horizon Shadow Occlusion</p>
        <p>- Raytraced Environment</p>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.156.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.156.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- 1. CORE SETUP ---
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 8, 35);

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2; 
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 10;
        controls.maxDistance = 90;

        // --- 2. HYBRID SCENE ARCHITECTURE ---
        const sceneRaymarch = new THREE.Scene();  // Keep Gemini black-hole/lensing core
        const sceneBack = new THREE.Scene();      // Old-style back layer for wrap-around
        const sceneFront = new THREE.Scene();     // Old-style front layer for wrap-around

        const orthoCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        const sharedUniforms = {
            uTime: { value: 0 },
            uSpinSpeed: { value: 0.1 },
            uCameraPos: { value: camera.position.clone() },
            uRadiusLimit: { value: 5.0 },
            uLayerAlpha: { value: 1.0 / 8.0 },
            uCoreBrightness: { value: 3.0 }
        };

        // --- 3. LAYER 1: GENERAL RELATIVITY RAYMARCHER ---
        const raymarchVertexShader = `
            varying vec2 vUv;
            void main() { vUv = uv; gl_Position = vec4(position, 1.0); }
        `;

        const raymarchFragmentShader = `
            uniform vec3 uCameraPos;
            uniform mat4 uCameraMatrix;
            uniform vec2 uResolution;
            uniform float uTime;
            uniform float uSpinSpeed;
            uniform float uRadiusLimit;
            uniform float uDiskBrightness;
            uniform float uLensStrength;

            varying vec2 vUv;

            float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
            float noise(vec2 st) {
                vec2 i = floor(st); vec2 f = fract(st);
                float a = random(i); float b = random(i + vec2(1.0, 0.0));
                float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0));
                vec2 u = f * f * (3.0 - 2.0 * f);
                return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
            }
            float fbm(vec2 st) {
                float value = 0.0; float amp = 0.5;
                for (int i = 0; i < 4; i++) {
                    value += amp * noise(st); st *= 2.0; amp *= 0.5;
                }
                return value;
            }

            void main() {
                vec2 uv = (vUv - 0.5) * 2.0;
                uv.x *= uResolution.x / uResolution.y;

                float fov = tan(45.0 * 0.5 * 3.14159 / 180.0);
                vec3 rayDir = normalize(vec3(uv.x * fov, uv.y * fov, -1.0));
                rayDir = (uCameraMatrix * vec4(rayDir, 0.0)).xyz;
                
                vec3 rayPos = uCameraPos;
                
                float rs = uRadiusLimit;
                vec3 h = cross(rayPos, rayDir);
                float h2 = dot(h, h);
                
                vec4 color = vec4(0.0);
                float dt = 0.05;
                bool hitHorizon = false;
                
                for(int i = 0; i < 200; i++) {
                    float r2 = dot(rayPos, rayPos);
                    float r = sqrt(r2);
                    
                    if(r < rs * 0.98) { hitHorizon = true; break; }
                    if(r > 150.0) { break; }
                    
                    vec3 accel = -1.5 * uLensStrength * h2 * rs * rayPos / (r2 * r2 * r);
                    rayDir = normalize(rayDir + accel * dt);
                    
                    float r_xz = length(rayPos.xz);
                    
                    // CRITICAL FIX: Add the ISCO (Innermost Stable Circular Orbit) gap
                    float isco = rs * 1.35;
                    
                    // Disk visuals come from layered plasma meshes below; keep raymarch for BH/lensing.
                    if(false && r_xz > isco && r_xz < 28.0) {
                        float scaleHeight = 0.03 * rs + pow(max(0.0, r_xz - isco)/15.0, 2.0) * 0.25;
                        float yDist = abs(rayPos.y);
                        float verticalFade = exp(-yDist * yDist / (scaleHeight * scaleHeight));
                        
                        if(verticalFade > 0.01) {
                            float omega = (2.0 * uSpinSpeed) * pow(isco / r_xz, 0.65);
                            float angle = atan(rayPos.z, rayPos.x) + uTime * omega;
                            
                            vec2 p2 = vec2(cos(angle)*r_xz, sin(angle)*r_xz) * 0.4;
                            vec2 w = vec2(fbm(p2 + vec2(2.1, 5.7)), fbm(p2 + vec2(8.3, 1.3)));
                            float gas = fbm(p2 * 1.5 + w * 2.0 - uTime * 0.15);
                            
                            float isInner = 1.0 - smoothstep(isco, isco + 1.5, r_xz);
                            float density = mix(smoothstep(0.2, 0.8, gas), 1.0, isInner) * verticalFade;
                            density *= 1.0 - smoothstep(18.0, 28.0, r_xz); 
                            
                            float temp = pow(isco / r_xz, 1.4);
                            vec3 c = mix(vec3(0.6, 0.05, 0.0), vec3(1.0, 0.4, 0.0), smoothstep(0.0, 0.3, temp));
                            c = mix(c, vec3(1.0, 0.85, 0.3), smoothstep(0.3, 0.7, temp));
                            c = mix(c, vec3(1.0, 1.0, 1.0), smoothstep(0.7, 1.0, temp));
                            
                            vec3 velDir = normalize(vec3(-rayPos.z, 0.0, rayPos.x));
                            float doppler = dot(-rayDir, velDir); 
                            
                            // CRITICAL FIX: Tone down the explosive relativistic math to stop the right side from blowing out
                            float beaming = 1.0 + doppler * 0.8; 
                            
                            vec3 em = c * beaming * uDiskBrightness * density;
                            float alpha = density * dt * 3.5;
                            
                            color.rgb += (1.0 - color.a) * em * dt;
                            color.a += (1.0 - color.a) * alpha;
                            
                            if(color.a > 0.99) break;
                        }
                    }
                    
                    dt = 0.04 * r;
                    float distToEquator = abs(rayPos.y);
                    if(distToEquator < 1.0 && r_xz < 30.0) {
                        dt = min(dt, max(0.015, distToEquator * 0.3));
                    }
                    if (rayPos.y * (rayPos.y + rayDir.y * dt) < 0.0) {
                        dt = min(dt, abs(rayPos.y / rayDir.y) + 0.001); 
                    }
                    rayPos += rayDir * dt;
                }
                
                if(!hitHorizon && color.a < 0.99) {
                    vec3 absDir = abs(rayDir);
                    float maxAxis = max(max(absDir.x, absDir.y), absDir.z);
                    vec3 boxPos = rayDir / maxAxis * 100.0;
                    
                    vec2 uvBox;
                    if(maxAxis == absDir.y) uvBox = boxPos.xz;
                    else if(maxAxis == absDir.x) uvBox = boxPos.yz;
                    else uvBox = boxPos.xy;
                    
                    vec2 grid = fract(uvBox * 0.15);
                    float line = step(0.96, grid.x) + step(0.96, grid.y);
                    vec3 roomCol = mix(vec3(0.015, 0.015, 0.02), vec3(0.0), clamp(line, 0.0, 1.0));
                    
                    float dist = length(boxPos);
                    roomCol += vec3(1.0, 0.5, 0.1) * (150.0 * rs / (dist * dist)) * (0.2 + 0.2 * uDiskBrightness); 
                    
                    color.rgb += (1.0 - color.a) * roomCol;
                }
                
                gl_FragColor = vec4(color.rgb, 1.0);
            }
        `;

        const raymarchMat = new THREE.ShaderMaterial({
            uniforms: {
                uCameraPos: { value: new THREE.Vector3() },
                uCameraMatrix: { value: new THREE.Matrix4() },
                uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                uTime: { value: 0 },
                uSpinSpeed: { value: 1.0 },
                uRadiusLimit: { value: 5.0 },
                uDiskBrightness: { value: 3.0 },
                uLensStrength: { value: 0.5 }
            },
            vertexShader: raymarchVertexShader,
            fragmentShader: raymarchFragmentShader,
            depthWrite: false
        });

        const quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), raymarchMat);
        sceneRaymarch.add(quad);


        // --- 4. LAYER 2: OLD-STYLE ACCRETION DISK + WRAPPED PARTICLES ---
        const plasmaVertexShader = `
            varying vec3 vWorldPosition;
            void main() {
                vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                gl_Position = projectionMatrix * viewMatrix * vec4(vWorldPosition, 1.0);
            }
        `;

        const plasmaFragmentShader = `
            uniform float uTime;
            uniform float uSpinSpeed;
            uniform vec3 uCameraPos;
            uniform float uRadiusLimit;
            uniform float uIsFront;
            uniform float uLayerAlpha;
            uniform float uCoreBrightness;

            varying vec3 vWorldPosition;

            float random(in vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
            float noise(in vec2 st) {
                vec2 i = floor(st); vec2 f = fract(st);
                float a = random(i); float b = random(i + vec2(1.0, 0.0));
                float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0));
                vec2 u = f * f * (3.0 - 2.0 * f);
                return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
            }
            float fbm(vec2 st) {
                float value = 0.0; float amp = 0.5;
                for (int i = 0; i < 4; i++) {
                    value += amp * noise(st); st *= 2.0; amp *= 0.5;
                }
                return value;
            }

            void main() {
                vec3 bhToPixel = vWorldPosition;
                vec3 camDir = normalize(vec3(0.0) - uCameraPos);
                float pixelDepth = dot(bhToPixel, camDir);

                // Match old behavior: render full disk in both passes.
                // The back pass is lensed; the front pass overlays, producing the wrap illusion.
                float passMask = 1.0;

                float r = length(vWorldPosition.xz);
                float innerEdge = uRadiusLimit + 0.1;
                if (r < innerEdge || r > 14.0) discard;

                float effR = max(r, uRadiusLimit);
                float temp = pow(uRadiusLimit / effR, 1.8);
                vec3 color = mix(vec3(0.5, 0.05, 0.0), vec3(1.0, 0.3, 0.0), smoothstep(0.0, 0.3, temp));
                color = mix(color, vec3(1.0, 0.8, 0.2), smoothstep(0.3, 0.7, temp));
                color = mix(color, vec3(1.0, 1.0, 1.0), smoothstep(0.7, 1.0, temp));

                float angle = atan(vWorldPosition.z, vWorldPosition.x);
                vec3 velocityDir = normalize(vec3(-sin(angle), 0.0, cos(angle)));
                vec3 viewDir = normalize(uCameraPos - vWorldPosition);
                float doppler = dot(velocityDir, viewDir);
                float beaming = 1.0 + doppler * 0.7;

                float omega = (2.0 * uSpinSpeed) * pow(uRadiusLimit / effR, 0.65);
                float c = cos(uTime * omega);
                float s = sin(uTime * omega);
                mat2 rot = mat2(c, s, -s, c);

                vec2 p = rot * (vWorldPosition.xz * 0.28);
                vec2 w = vec2(fbm(p + vec2(2.1, 5.7)), fbm(p + vec2(8.3, 1.3)));
                p += (w - 0.5) * 2.2;

                float gas = fbm(p * 1.7 + vec2(0.0, uTime * 0.12));
                float density = mix(0.1, 1.0, smoothstep(0.3, 0.8, gas));

                float photonRing = 1.0 - smoothstep(uRadiusLimit, uRadiusLimit + 0.3, r);
                vec3 finalColor = (color * beaming * 2.0) + (vec3(1.0, 0.9, 0.6) * photonRing * 3.5);
                finalColor *= uCoreBrightness;

                float outerFade = 1.0 - smoothstep(10.0, 14.0, r);
                float viewAngle = abs(normalize(uCameraPos).y);
                float edgeBoost = 1.0 + (1.0 - viewAngle) * 1.5;

                float alpha = outerFade * density * 1.2 * uLayerAlpha * passMask * edgeBoost;
                gl_FragColor = vec4(finalColor, alpha);
            }
        `;

        const plasmaGeo = new THREE.PlaneGeometry(30, 30);
        const plasmaMatBack = new THREE.ShaderMaterial({
            uniforms: { ...sharedUniforms, uIsFront: { value: 0.0 } },
            vertexShader: plasmaVertexShader,
            fragmentShader: plasmaFragmentShader,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            side: THREE.DoubleSide
        });
        const plasmaMatFront = new THREE.ShaderMaterial({
            uniforms: { ...sharedUniforms, uIsFront: { value: 1.0 } },
            vertexShader: plasmaVertexShader,
            fragmentShader: plasmaFragmentShader,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            side: THREE.DoubleSide
        });
        plasmaMatFront.depthTest = false;

        const DISK_LAYERS = 8;
        const DISK_THICKNESS = 0.25;
        for (let i = 0; i < DISK_LAYERS; i++) {
            const t = i / (DISK_LAYERS - 1);
            const y = THREE.MathUtils.lerp(-DISK_THICKNESS * 0.5, DISK_THICKNESS * 0.5, t);

            const b = new THREE.Mesh(plasmaGeo, plasmaMatBack);
            b.rotation.x = -Math.PI / 2;
            b.position.y = y;
            sceneBack.add(b);

            const f = new THREE.Mesh(plasmaGeo, plasmaMatFront);
            f.rotation.x = -Math.PI / 2;
            f.position.y = y;
            sceneFront.add(f);
        }

        const particleCount = 60000;
        const particlePositions = new Float32Array(particleCount * 3);
        const particleAngles = new Float32Array(particleCount);
        const particleRadii = new Float32Array(particleCount);
        const particleSizes = new Float32Array(particleCount);

        for (let i = 0; i < particleCount; i++) {
            const r = Math.pow(Math.random(), 1.5) * 24.0;
            const theta = Math.random() * Math.PI * 2;

            particleRadii[i] = r;
            particleAngles[i] = theta;
            particleSizes[i] = (Math.random() * 1.5 + 0.5) * (r / 10.0);

            particlePositions[i * 3] = r * Math.cos(theta);
            const verticalSpread = Math.pow(Math.max(0.0, r - 3.0) / 15.0, 2.0) * 2.2;
            particlePositions[i * 3 + 1] = (Math.random() - 0.5) * verticalSpread;
            particlePositions[i * 3 + 2] = r * Math.sin(theta);
        }

        const particleGeo = new THREE.BufferGeometry();
        particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        particleGeo.setAttribute('aAngle', new THREE.BufferAttribute(particleAngles, 1));
        particleGeo.setAttribute('aRadius', new THREE.BufferAttribute(particleRadii, 1));
        particleGeo.setAttribute('aSize', new THREE.BufferAttribute(particleSizes, 1));

        const particleVertexShader = `
            uniform float uTime;
            uniform float uSpinSpeed;
            uniform vec3 uCameraPos;
            uniform float uRadiusLimit;

            attribute float aAngle;
            attribute float aRadius;
            attribute float aSize;

            varying float vDoppler;
            varying float vRadius;
            varying float vPixelDepth;
            varying vec3 vWorldPosition;

            void main() {
                vRadius = aRadius;
                float effR = max(aRadius, uRadiusLimit);
                float speed = 18.0 / sqrt(effR);
                float currentAngle = aAngle + (uTime * speed * uSpinSpeed);

                vec3 newPos = position;
                newPos.x = aRadius * cos(currentAngle);
                newPos.z = aRadius * sin(currentAngle);
                newPos.y += sin(uTime * 1.5 + aAngle * 10.0) * 0.15;

                vec4 worldPosition = modelMatrix * vec4(newPos, 1.0);
                vWorldPosition = worldPosition.xyz;

                vec3 bhToPixel = worldPosition.xyz;
                vec3 camDir = normalize(vec3(0.0) - uCameraPos);
                vPixelDepth = dot(bhToPixel, camDir);

                vec3 velocityDir = normalize(vec3(-sin(currentAngle), 0.0, cos(currentAngle)));
                vec3 viewDir = normalize(uCameraPos - worldPosition.xyz);
                vDoppler = dot(velocityDir, viewDir);

                vec4 mvPosition = viewMatrix * worldPosition;
                gl_PointSize = (aSize * 90.0) / -mvPosition.z;
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const particleFragmentShader = `
            uniform float uRadiusLimit;
            uniform float uIsFront;
            uniform vec3 uCameraPos;
            uniform float uParticleBrightness;
            uniform float uCoreBrightness;

            varying float vDoppler;
            varying float vRadius;
            varying float vPixelDepth;
            varying vec3 vWorldPosition;

            void main() {
                // Match old behavior: render full particle set in both passes.
                float passMask = 1.0;
                if (vRadius < uRadiusLimit + 0.08) discard;

                vec2 coord = gl_PointCoord - vec2(0.5);
                float dist = length(coord);
                if (dist > 0.5) discard;
                float alpha = exp(-dist * dist * 12.0) * 0.18;

                float effR = max(vRadius, uRadiusLimit);
                float temp = pow(uRadiusLimit / effR, 1.8);
                vec3 color = mix(vec3(0.6, 0.1, 0.0), vec3(1.0, 0.5, 0.1), smoothstep(0.0, 0.4, temp));
                color = mix(color, vec3(1.0, 0.9, 0.8), smoothstep(0.4, 1.0, temp));

                float beaming = 1.0 + vDoppler * 0.7;
                float edgeFade = 1.0 - smoothstep(15.0, 24.0, vRadius);
                float innerFade = smoothstep(uRadiusLimit + 0.12, uRadiusLimit + 0.9, vRadius);

                gl_FragColor = vec4(color * beaming * uParticleBrightness * uCoreBrightness, alpha * edgeFade * passMask * innerFade);
            }
        `;

        const pMatBack = new THREE.ShaderMaterial({
            uniforms: { ...sharedUniforms, uParticleBrightness: { value: 3.0 }, uIsFront: { value: 0.0 } },
            vertexShader: particleVertexShader,
            fragmentShader: particleFragmentShader,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });
        const pMatFront = new THREE.ShaderMaterial({
            uniforms: { ...sharedUniforms, uParticleBrightness: { value: 3.0 }, uIsFront: { value: 1.0 } },
            vertexShader: particleVertexShader,
            fragmentShader: particleFragmentShader,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });
        pMatFront.depthTest = false;

        const backParticles = new THREE.Points(particleGeo, pMatBack);
        const frontParticles = new THREE.Points(particleGeo, pMatFront);
        sceneBack.add(backParticles);
        sceneFront.add(frontParticles);

        // --- 5. POST LENSING PASS (back layer only) ---
        const LensingShader = {
            uniforms: {
                tDiffuse: { value: null },
                center: { value: new THREE.Vector2(0.5, 0.5) },
                radius: { value: 0.1 },
                strength: { value: 0.5 },
                aspectRatio: { value: window.innerWidth / window.innerHeight },
                uCameraPos: { value: camera.position.clone() },
                uCoreBrightness: { value: 3.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform vec2 center;
                uniform float radius;
                uniform float strength;
                uniform float aspectRatio;
                uniform vec3 uCameraPos;
                uniform float uCoreBrightness;
                varying vec2 vUv;

                void main() {
                    vec2 uv = vUv;
                    vec2 delta = uv - center;
                    delta.x *= aspectRatio;
                    float dist = length(delta);
                    float safeDist = max(dist, 0.0001);
                    vec4 baseColor = texture2D(tDiffuse, uv);

                    // Preserve underlying horizon from Gemini raymarch in the center.
                    if (dist < radius * 0.98) {
                        gl_FragColor = baseColor;
                        return;
                    }

                    float viewAngle = abs(normalize(uCameraPos).y);
                    float effectiveStrength = strength * (1.0 - viewAngle * 0.85);
                    float deflection = effectiveStrength * (radius * radius) / safeDist;
                    float sourceDist = dist - deflection;

                    vec2 dir = delta / safeDist;
                    vec2 distortedUv = center + dir * sourceDist * vec2(1.0 / aspectRatio, 1.0);

                    vec2 duv = distortedUv;
                    float inBounds = step(0.0, duv.x) * step(duv.x, 1.0) * step(0.0, duv.y) * step(duv.y, 1.0);
                    duv = clamp(duv, 0.0, 1.0);
                    vec4 warpedColor = texture2D(tDiffuse, duv);
                    vec4 texColor = mix(baseColor, warpedColor, inBounds);

                    // Gemini already raymarches the horizon shadow; avoid painting a second black disk here.
                    float horizonAbsorb = 1.0 - smoothstep(radius * 0.90, radius * 0.98, dist);
                    texColor.rgb *= (1.0 - 0.15 * horizonAbsorb);

                    float photonRing = 1.0 - smoothstep(radius * 0.98, radius * 1.05, dist);
                    vec4 ringColor = vec4(1.0, 0.9, 0.7, 1.0) * photonRing * (1.5 * uCoreBrightness);

                    gl_FragColor = texColor + ringColor;
                }
            `
        };


        // --- 6. PIPELINE ---
        const composer = new EffectComposer(renderer);
        
        // Pass 1: Draw the heavily mathematical curved spacetime background
        const bgPass = new RenderPass(sceneRaymarch, orthoCamera);
        bgPass.clearColor = new THREE.Color(0x000000);
        bgPass.clearAlpha = 1.0;
        composer.addPass(bgPass);

        // Pass 2: Back layer (disk + particles)
        const backPass = new RenderPass(sceneBack, camera);
        backPass.clear = false;
        composer.addPass(backPass);

        // Pass 3: Lens only the back layer before front overlays
        const lensingPass = new ShaderPass(LensingShader);
        lensingPass.material.depthTest = false;
        lensingPass.material.depthWrite = false;
        composer.addPass(lensingPass);

        // Pass 4: Front layer (disk + particles)
        const frontPass = new RenderPass(sceneFront, camera);
        frontPass.clear = false;
        frontPass.clearDepth = true;
        composer.addPass(frontPass);

        // Pass 5: Cinematic Bloom
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.8, 0.5, 0.85);
        bloomPass.threshold = 0.2;
        composer.addPass(bloomPass);

        // --- 7. CONTROLS & RENDER LOOP ---
        const gui = new GUI({ title: 'Black Hole Physics' });
        const params = {
            spinSpeed: 0.1,
            lensStrength: 0.5,
            diskBrightness: 3.0,
            particleBrightness: 3.0,
            showParticles: true,
            radius: 5.0,
            autoOrbit: false,
            expand: () => triggerExpansion()
        };
        gui.add(params, 'spinSpeed', 0.0, 2.0).name('Time Scale');
        gui.add(params, 'lensStrength', 0.0, 3.5).name('Lensing Strength');
        gui.add(params, 'diskBrightness', 0.0, 15.0).name('Core Brightness');
        gui.add(params, 'particleBrightness', 0.0, 6.0).name('Gas Brightness');
        gui.add(params, 'showParticles').name('Show Particles').onChange((enabled) => {
            backParticles.visible = enabled;
            frontParticles.visible = enabled;
        });
        gui.add(params, 'radius', 1.0, 8.0).name('Black Hole Mass').listen();
        gui.add(params, 'autoOrbit').name('Auto Camera Orbit');
        gui.add(params, 'expand').name('Simulate Growth');

        let isExpanding = false;
        let expansionTime = 0;
        let currentScale = 1.0;

        function triggerExpansion() {
            if(isExpanding) return;
            isExpanding = true;
            expansionTime = 0;
            currentScale = 0.1;
        }

        const clock = new THREE.Clock();
        const cameraMat = new THREE.Matrix4();
        const bhWorldPos = new THREE.Vector3();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            if (params.autoOrbit) {
                // Slowly pan the camera around the black hole automatically
                camera.position.x = Math.cos(time * 0.1) * 35;
                camera.position.z = Math.sin(time * 0.1) * 35;
                camera.lookAt(0, 0, 0);
            }
            controls.update();

            cameraMat.extractRotation(camera.matrixWorld);
            
            raymarchMat.uniforms.uCameraPos.value.copy(camera.position);
            raymarchMat.uniforms.uCameraMatrix.value.copy(cameraMat);
            raymarchMat.uniforms.uTime.value = time;
            raymarchMat.uniforms.uSpinSpeed.value = params.spinSpeed;
            raymarchMat.uniforms.uDiskBrightness.value = params.diskBrightness;
            // Keep raymarch shadow stable: high lens slider should increase wrap, not inflate a giant black orb.
            const raymarchStrength = THREE.MathUtils.clamp(
                params.lensStrength * (2.5 / Math.max(params.radius, 0.5)),
                0.0,
                0.65
            );
            raymarchMat.uniforms.uLensStrength.value = raymarchStrength;
            
            sharedUniforms.uCameraPos.value.copy(camera.position);
            sharedUniforms.uTime.value = time;
            sharedUniforms.uSpinSpeed.value = params.spinSpeed;
            sharedUniforms.uCoreBrightness.value = params.diskBrightness;
            pMatBack.uniforms.uParticleBrightness.value = params.particleBrightness;
            pMatFront.uniforms.uParticleBrightness.value = params.particleBrightness;
            lensingPass.uniforms.uCameraPos.value.copy(camera.position);
            // Old-style wrap coupling: mass and lensing both influence the wrap amount.
            const wrapStrength = THREE.MathUtils.clamp(params.lensStrength * (params.radius / 2.5), 0.0, 3.5);
            lensingPass.uniforms.strength.value = wrapStrength;
            lensingPass.uniforms.uCoreBrightness.value = params.diskBrightness;

            if (isExpanding) {
                expansionTime += delta;
                const progress = Math.min(expansionTime / 3.0, 1.0);
                const easeOut = 1 - Math.pow(1 - progress, 3);
                currentScale = 0.1 + (easeOut * 0.9); 
                params.radius = 3.0 * currentScale; // Updates UI
                if (progress >= 1.0) isExpanding = false;
            }

            raymarchMat.uniforms.uRadiusLimit.value = params.radius;
            sharedUniforms.uRadiusLimit.value = params.radius;
            
            bhWorldPos.set(0, 0, 0).project(camera);
            lensingPass.uniforms.center.value.set((bhWorldPos.x + 1) * 0.5, (bhWorldPos.y + 1) * 0.5);

            const dist = camera.position.length();
            const vFOV = THREE.MathUtils.degToRad(camera.fov);
            const viewHeight = 2 * Math.tan(vFOV * 0.5) * dist;
            lensingPass.uniforms.radius.value = params.radius / Math.max(viewHeight, 0.0001);

            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            raymarchMat.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
            lensingPass.uniforms.aspectRatio.value = window.innerWidth / window.innerHeight;
        });

        animate();
    </script>
</body>
</html>
