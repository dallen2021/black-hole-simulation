<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realistic Black Hole Prototype</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #info {
            position: absolute; top: 10px; left: 10px; color: rgba(255,255,255,0.8);
            background: rgba(0,0,0,0.5); padding: 15px; border-radius: 8px;
            pointer-events: none; border: 1px solid rgba(255,255,255,0.2);
            z-index: 100;
        }
        h1 { margin: 0 0 5px 0; font-size: 18px; color: #ff9d00; }
        p { margin: 0; font-size: 12px; }
    </style>
</head>
<body>
    <div id="info">
        <h1>Hybrid Ray-Marching Engine</h1>
        <p>Real Relativistic Physics Applied:</p>
        <p>- Pure Mathematical Light Bending</p>
        <p>- 3D Volumetric Particle Swarm</p>
        <p>- Event Horizon Shadow Occlusion</p>
        <p>- Raytraced Environment</p>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.156.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.156.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- 1. CORE SETUP ---
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 8, 35);

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2; 
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 10;
        controls.maxDistance = 90;

        // --- 2. HYBRID SCENE ARCHITECTURE ---
        const sceneRoom = new THREE.Scene();
        const sceneRaymarch = new THREE.Scene(); // Keeps the accretion disk + black hole from sim.html
        const sceneParticlesBack = new THREE.Scene();
        const sceneParticlesFront = new THREE.Scene();

        const orthoCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        // --- 2.5 ROOM FROM BlackHole_simulation.html ---
        const roomCanvas = document.createElement('canvas');
        roomCanvas.width = 256; roomCanvas.height = 256;
        const roomCtx = roomCanvas.getContext('2d');
        roomCtx.fillStyle = '#0a0a0a'; roomCtx.fillRect(0, 0, 256, 256);
        roomCtx.fillStyle = '#1c1c1c'; roomCtx.fillRect(4, 4, 248, 248);
        const tileTex = new THREE.CanvasTexture(roomCanvas);
        tileTex.wrapS = THREE.RepeatWrapping;
        tileTex.wrapT = THREE.RepeatWrapping;
        tileTex.repeat.set(12, 12);

        const roomGeo = new THREE.PlaneGeometry(100, 100);
        const roomMat = new THREE.MeshStandardMaterial({ map: tileTex, roughness: 0.4, metalness: 0.6 });

        const floor = new THREE.Mesh(roomGeo, roomMat);
        floor.rotation.x = -Math.PI / 2; floor.position.y = -18;
        floor.receiveShadow = true;
        sceneRoom.add(floor);

        const ceil = new THREE.Mesh(roomGeo, roomMat);
        ceil.rotation.x = Math.PI / 2; ceil.position.y = 25;
        ceil.receiveShadow = true;
        sceneRoom.add(ceil);

        const backWall = new THREE.Mesh(new THREE.PlaneGeometry(100, 45), roomMat);
        backWall.position.z = -50; backWall.position.y = 3.5;
        backWall.receiveShadow = true;
        sceneRoom.add(backWall);

        const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(100, 45), roomMat);
        leftWall.rotation.y = Math.PI / 2; leftWall.position.x = -50; leftWall.position.y = 3.5;
        leftWall.receiveShadow = true;
        sceneRoom.add(leftWall);

        const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(100, 45), roomMat);
        rightWall.rotation.y = -Math.PI / 2; rightWall.position.x = 50; rightWall.position.y = 3.5;
        rightWall.receiveShadow = true;
        sceneRoom.add(rightWall);

        const pillarGeo = new THREE.BoxGeometry(4, 45, 4);
        const pillarMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8 });
        const pillarPositions = [[-20, -20], [20, -20], [-35, -35], [35, -35], [0, -40]];
        pillarPositions.forEach((pos) => {
            const pillar = new THREE.Mesh(pillarGeo, pillarMat);
            pillar.position.set(pos[0], 3.5, pos[1]);
            pillar.castShadow = true;
            pillar.receiveShadow = true;
            sceneRoom.add(pillar);
        });

        const diskLight = new THREE.PointLight(0xffaa44, 18000, 100, 2);
        diskLight.position.set(0, 0, 0);
        diskLight.castShadow = true;
        diskLight.shadow.mapSize.width = 2048;
        diskLight.shadow.mapSize.height = 2048;
        diskLight.shadow.bias = -0.002;
        sceneRoom.add(diskLight);
        sceneRoom.add(new THREE.AmbientLight(0x223344, 0.5));

        // --- 3. LAYER 1: GENERAL RELATIVITY RAYMARCHER ---
        const raymarchVertexShader = `
            varying vec2 vUv;
            void main() { vUv = uv; gl_Position = vec4(position, 1.0); }
        `;

        const raymarchFragmentShader = `
            uniform vec3 uCameraPos;
            uniform mat4 uCameraMatrix;
            uniform vec2 uResolution;
            uniform float uTime;
            uniform float uSpinSpeed;
            uniform float uRadiusLimit;
            uniform float uDiskBrightness;
            uniform float uLensStrength;

            varying vec2 vUv;

            float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
            float noise(vec2 st) {
                vec2 i = floor(st); vec2 f = fract(st);
                float a = random(i); float b = random(i + vec2(1.0, 0.0));
                float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0));
                vec2 u = f * f * (3.0 - 2.0 * f);
                return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
            }
            float fbm(vec2 st) {
                float value = 0.0; float amp = 0.5;
                for (int i = 0; i < 4; i++) {
                    value += amp * noise(st); st *= 2.0; amp *= 0.5;
                }
                return value;
            }

            float bhShadow(vec3 ro, vec3 rd, float tMax, float radius) {
                vec3 oc = ro;
                float b = dot(oc, rd);
                float c = dot(oc, oc) - radius * radius;
                float h = b * b - c;
                if (h <= 0.0) return 1.0;
                float t = -b - sqrt(h);
                if (t > 0.001 && t < tMax) return 0.0;
                return 1.0;
            }

            float intersectRoom(vec3 ro, vec3 rd, vec3 roomHalf, out vec3 normal, out float matId) {
                float tMin = 1e19;
                normal = vec3(0.0);
                matId = 0.0;

                if (abs(rd.x) > 0.0001) {
                    float t = (-roomHalf.x - ro.x) / rd.x;
                    vec3 p = ro + rd * t;
                    if (t > 0.001 && abs(p.y) <= roomHalf.y && abs(p.z) <= roomHalf.z && t < tMin) { tMin = t; normal = vec3(1.0, 0.0, 0.0); matId = 3.0; }
                    t = (roomHalf.x - ro.x) / rd.x;
                    p = ro + rd * t;
                    if (t > 0.001 && abs(p.y) <= roomHalf.y && abs(p.z) <= roomHalf.z && t < tMin) { tMin = t; normal = vec3(-1.0, 0.0, 0.0); matId = 3.0; }
                }
                if (abs(rd.y) > 0.0001) {
                    float t = (-roomHalf.y - ro.y) / rd.y;
                    vec3 p = ro + rd * t;
                    if (t > 0.001 && abs(p.x) <= roomHalf.x && abs(p.z) <= roomHalf.z && t < tMin) { tMin = t; normal = vec3(0.0, 1.0, 0.0); matId = 1.0; }
                    t = (roomHalf.y - ro.y) / rd.y;
                    p = ro + rd * t;
                    if (t > 0.001 && abs(p.x) <= roomHalf.x && abs(p.z) <= roomHalf.z && t < tMin) { tMin = t; normal = vec3(0.0, -1.0, 0.0); matId = 2.0; }
                }
                if (abs(rd.z) > 0.0001) {
                    float t = (-roomHalf.z - ro.z) / rd.z;
                    vec3 p = ro + rd * t;
                    if (t > 0.001 && abs(p.x) <= roomHalf.x && abs(p.y) <= roomHalf.y && t < tMin) { tMin = t; normal = vec3(0.0, 0.0, 1.0); matId = 4.0; }
                    t = (roomHalf.z - ro.z) / rd.z;
                    p = ro + rd * t;
                    if (t > 0.001 && abs(p.x) <= roomHalf.x && abs(p.y) <= roomHalf.y && t < tMin) { tMin = t; normal = vec3(0.0, 0.0, -1.0); matId = 3.0; }
                }
                return tMin;
            }

            vec3 roomBaseColor(vec3 p, float matId) {
                if (matId < 1.5) {
                    vec2 tile = p.xz * 0.35;
                    float checker = mod(floor(tile.x) + floor(tile.y), 2.0);
                    vec2 f = abs(fract(tile) - 0.5);
                    float grout = 1.0 - smoothstep(0.46, 0.5, max(f.x, f.y));
                    vec3 floorCol = mix(vec3(0.11, 0.12, 0.14), vec3(0.06, 0.07, 0.09), checker);
                    return mix(floorCol, vec3(0.025), grout * 0.85);
                }
                if (matId < 2.5) {
                    float stripe = 1.0 - smoothstep(0.04, 0.17, abs(fract(p.x * 0.10) - 0.5));
                    return vec3(0.14, 0.15, 0.17) + vec3(0.02) * stripe;
                }
                if (matId < 3.5) {
                    float panel = 1.0 - smoothstep(0.08, 0.22, abs(fract(p.y * 0.12) - 0.5));
                    return vec3(0.10, 0.11, 0.13) + vec3(0.025) * panel;
                }
                float vents = 1.0 - smoothstep(0.05, 0.18, abs(fract(p.x * 0.12) - 0.5));
                return vec3(0.08, 0.09, 0.11) + vec3(0.03, 0.02, 0.015) * vents;
            }

            vec3 roomShade(vec3 p, vec3 n, vec3 viewDir, float rs, float matId, vec3 roomHalf) {
                vec3 base = roomBaseColor(p, matId);
                vec3 col = base * vec3(0.08, 0.09, 0.11);

                vec3 lp0 = vec3(-22.0, roomHalf.y - 2.0, -15.0);
                vec3 lp1 = vec3(20.0, roomHalf.y - 2.5, 18.0);
                vec3 lp2 = vec3(0.0, 8.0, -roomHalf.z + 7.0);

                vec3 l0 = lp0 - p;
                float d0 = max(length(l0), 0.001);
                l0 /= d0;
                float vis0 = bhShadow(p + n * 0.05, l0, d0, rs * 2.3);
                float diff0 = max(dot(n, l0), 0.0);
                vec3 h0 = normalize(l0 + viewDir);
                float spec0 = pow(max(dot(n, h0), 0.0), 36.0) * 0.28;
                col += base * vec3(1.00, 0.96, 0.90) * (diff0 + spec0) * (5.0 / (1.0 + d0 * d0 * 0.02)) * vis0;

                vec3 l1 = lp1 - p;
                float d1 = max(length(l1), 0.001);
                l1 /= d1;
                float vis1 = bhShadow(p + n * 0.05, l1, d1, rs * 2.3);
                float diff1 = max(dot(n, l1), 0.0);
                vec3 h1 = normalize(l1 + viewDir);
                float spec1 = pow(max(dot(n, h1), 0.0), 32.0) * 0.22;
                col += base * vec3(0.72, 0.86, 1.00) * (diff1 + spec1) * (4.2 / (1.0 + d1 * d1 * 0.02)) * vis1;

                vec3 l2 = lp2 - p;
                float d2 = max(length(l2), 0.001);
                l2 /= d2;
                float vis2 = bhShadow(p + n * 0.05, l2, d2, rs * 2.3);
                float diff2 = max(dot(n, l2), 0.0);
                vec3 h2v = normalize(l2 + viewDir);
                float spec2 = pow(max(dot(n, h2v), 0.0), 28.0) * 0.18;
                col += base * vec3(1.00, 0.42, 0.16) * (diff2 + spec2) * (3.0 / (1.0 + d2 * d2 * 0.02)) * vis2;

                col += base * vec3(1.0, 0.45, 0.12) * (18.0 * rs / (dot(p, p) + 100.0));
                return col;
            }

            void main() {
                vec2 uv = (vUv - 0.5) * 2.0;
                uv.x *= uResolution.x / uResolution.y;

                float fov = tan(45.0 * 0.5 * 3.14159 / 180.0);
                vec3 rayDir = normalize(vec3(uv.x * fov, uv.y * fov, -1.0));
                rayDir = (uCameraMatrix * vec4(rayDir, 0.0)).xyz;
                
                vec3 rayPos = uCameraPos;
                
                float rs = uRadiusLimit;
                vec3 h = cross(rayPos, rayDir);
                float h2 = dot(h, h);
                
                vec4 color = vec4(0.0);
                float dt = 0.05;
                bool hitHorizon = false;
                
                for(int i = 0; i < 200; i++) {
                    float r2 = dot(rayPos, rayPos);
                    float r = sqrt(r2);
                    
                    if(r < rs * 0.98) { hitHorizon = true; break; }
                    if(r > 150.0) { break; }
                    
                    vec3 accel = -1.5 * uLensStrength * h2 * rs * rayPos / (r2 * r2 * r);
                    rayDir = normalize(rayDir + accel * dt);
                    
                    float r_xz = length(rayPos.xz);
                    
                    // CRITICAL FIX: Add the ISCO (Innermost Stable Circular Orbit) gap
                    float isco = rs * 1.35;
                    
                    if(r_xz > isco && r_xz < 28.0) {
                        float scaleHeight = 0.03 * rs + pow(max(0.0, r_xz - isco)/15.0, 2.0) * 0.25;
                        float yDist = abs(rayPos.y);
                        float verticalFade = exp(-yDist * yDist / (scaleHeight * scaleHeight));
                        
                        if(verticalFade > 0.01) {
                            float omega = (2.0 * uSpinSpeed) * pow(isco / r_xz, 0.65);
                            float angle = atan(rayPos.z, rayPos.x) + uTime * omega;
                            
                            vec2 p2 = vec2(cos(angle)*r_xz, sin(angle)*r_xz) * 0.4;
                            vec2 w = vec2(fbm(p2 + vec2(2.1, 5.7)), fbm(p2 + vec2(8.3, 1.3)));
                            float gas = fbm(p2 * 1.5 + w * 2.0 - uTime * 0.15);
                            
                            float isInner = 1.0 - smoothstep(isco, isco + 1.5, r_xz);
                            float density = mix(smoothstep(0.2, 0.8, gas), 1.0, isInner) * verticalFade;
                            density *= 1.0 - smoothstep(18.0, 28.0, r_xz); 
                            
                            float temp = pow(isco / r_xz, 1.4);
                            vec3 c = mix(vec3(0.6, 0.05, 0.0), vec3(1.0, 0.4, 0.0), smoothstep(0.0, 0.3, temp));
                            c = mix(c, vec3(1.0, 0.85, 0.3), smoothstep(0.3, 0.7, temp));
                            c = mix(c, vec3(1.0, 1.0, 1.0), smoothstep(0.7, 1.0, temp));
                            
                            vec3 velDir = normalize(vec3(-rayPos.z, 0.0, rayPos.x));
                            float doppler = dot(-rayDir, velDir); 
                            
                            // CRITICAL FIX: Tone down the explosive relativistic math to stop the right side from blowing out
                            float beaming = 1.0 + doppler * 0.8; 
                            
                            vec3 em = c * beaming * uDiskBrightness * density;
                            float alpha = density * dt * 3.5;
                            
                            color.rgb += (1.0 - color.a) * em * dt;
                            color.a += (1.0 - color.a) * alpha;
                            
                            if(color.a > 0.99) break;
                        }
                    }
                    
                    dt = 0.04 * r;
                    float distToEquator = abs(rayPos.y);
                    if(distToEquator < 1.0 && r_xz < 30.0) {
                        dt = min(dt, max(0.015, distToEquator * 0.3));
                    }
                    if (rayPos.y * (rayPos.y + rayDir.y * dt) < 0.0) {
                        dt = min(dt, abs(rayPos.y / rayDir.y) + 0.001); 
                    }
                    rayPos += rayDir * dt;
                }
                
                float holeAlpha = hitHorizon ? 1.0 : 0.0;
                float outAlpha = max(color.a, holeAlpha);
                gl_FragColor = vec4(color.rgb, outAlpha);
            }
        `;

        const raymarchMat = new THREE.ShaderMaterial({
            uniforms: {
                uCameraPos: { value: new THREE.Vector3() },
                uCameraMatrix: { value: new THREE.Matrix4() },
                uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                uTime: { value: 0 },
                uSpinSpeed: { value: 0.1 },
                uRadiusLimit: { value: 2.0 },
                uDiskBrightness: { value: 4.0 },
                uLensStrength: { value: 1.0 }
            },
            vertexShader: raymarchVertexShader,
            fragmentShader: raymarchFragmentShader,
            depthWrite: false,
            depthTest: false,
            transparent: true
        });

        const quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), raymarchMat);
        sceneRaymarch.add(quad);


        // --- 4. LAYER 2: VOLUMETRIC GAS PARTICLES (FROM BlackHole_simulation.html) ---
        const particleCount = 60000;
        const particlePositions = new Float32Array(particleCount * 3);
        const particleAngles = new Float32Array(particleCount);
        const particleRadii = new Float32Array(particleCount);
        const particleSizes = new Float32Array(particleCount);

        for (let i = 0; i < particleCount; i++) {
            const r = Math.pow(Math.random(), 1.5) * 24.0;
            const theta = Math.random() * Math.PI * 2;

            particleRadii[i] = r;
            particleAngles[i] = theta;
            particleSizes[i] = (Math.random() * 1.5 + 0.5) * (r / 10.0);

            particlePositions[i * 3] = r * Math.cos(theta);
            const verticalSpread = Math.pow(Math.max(0.0, r - 3.0) / 15.0, 2.0) * 2.2;
            particlePositions[i * 3 + 1] = (Math.random() - 0.5) * verticalSpread;
            particlePositions[i * 3 + 2] = r * Math.sin(theta);
        }

        const particleGeo = new THREE.BufferGeometry();
        particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        particleGeo.setAttribute('aAngle', new THREE.BufferAttribute(particleAngles, 1));
        particleGeo.setAttribute('aRadius', new THREE.BufferAttribute(particleRadii, 1));
        particleGeo.setAttribute('aSize', new THREE.BufferAttribute(particleSizes, 1));

        const particleVertexShader = `
            uniform float uTime;
            uniform float uSpinSpeed;
            uniform vec3 uCameraPos;
            uniform float uRadiusLimit;

            attribute float aAngle;
            attribute float aRadius;
            attribute float aSize;

            varying float vDoppler;
            varying float vRadius;
            varying float vPixelDepth;
            varying vec3 vWorldPosition;

            void main() {
                vRadius = aRadius;
                float effR = max(aRadius, uRadiusLimit);
                float speed = 18.0 / sqrt(effR);
                float currentAngle = aAngle + (uTime * speed * uSpinSpeed);

                vec3 newPos = position;
                newPos.x = aRadius * cos(currentAngle);
                newPos.z = aRadius * sin(currentAngle);
                newPos.y += sin(uTime * 1.5 + aAngle * 10.0) * 0.15;

                vec4 worldPosition = modelMatrix * vec4(newPos, 1.0);
                vWorldPosition = worldPosition.xyz;

                vec3 bhToPixel = worldPosition.xyz;
                vec3 camDir = normalize(vec3(0.0) - uCameraPos);
                vPixelDepth = dot(bhToPixel, camDir);

                vec3 velocityDir = normalize(vec3(-sin(currentAngle), 0.0, cos(currentAngle)));
                vec3 viewDir = normalize(uCameraPos - worldPosition.xyz);
                vDoppler = dot(velocityDir, viewDir);

                vec4 mvPosition = viewMatrix * worldPosition;
                gl_PointSize = (aSize * 90.0) / -mvPosition.z;
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const particleFragmentShader = `
            uniform float uRadiusLimit;
            uniform float uIsFront;
            uniform vec3 uCameraPos;
            uniform float uParticleBrightness;
            uniform vec2 uResolution;
            uniform vec2 uLensCenter;
            uniform float uLensRadius;
            uniform float uLensStrength;
            uniform float uAspectRatio;

            varying float vDoppler;
            varying float vRadius;
            varying float vPixelDepth;
            varying vec3 vWorldPosition;

            void main() {
                float backMask = smoothstep(-0.1, 0.1, vPixelDepth);
                float passMask = mix(backMask, 1.0 - backMask, uIsFront);
                if (passMask <= 0.01) discard;

                // Also clip particles inside the lensed screen-space shadow region.
                vec2 screenUv = gl_FragCoord.xy / uResolution;
                vec2 lensDelta = screenUv - uLensCenter;
                lensDelta.x *= uAspectRatio;
                float lensDist = length(lensDelta);
                float lensShadowRadius = uLensRadius * (1.0 + uLensStrength * 0.35);
                if (lensDist < lensShadowRadius * 0.99) discard;

                // Prevent particles from rendering through the black-hole shadow.
                vec3 toParticle = vWorldPosition - uCameraPos;
                float distToParticle = length(toParticle);
                vec3 rayDir = toParticle / max(distToParticle, 0.0001);
                float shadowRadius = uRadiusLimit * 2.5;
                float b = dot(uCameraPos, rayDir);
                float c = dot(uCameraPos, uCameraPos) - shadowRadius * shadowRadius;
                float d = b * b - c;
                if (d > 0.0) {
                    float t = -b - sqrt(d);
                    if (t > 0.0 && t < distToParticle) discard;
                }

                vec2 coord = gl_PointCoord - vec2(0.5);
                float dist = length(coord);
                if (dist > 0.5) discard;
                float alpha = exp(-dist * dist * 12.0) * 0.18;

                float effR = max(vRadius, uRadiusLimit);
                float temp = pow(uRadiusLimit / effR, 1.8);
                vec3 color = mix(vec3(0.6, 0.1, 0.0), vec3(1.0, 0.5, 0.1), smoothstep(0.0, 0.4, temp));
                color = mix(color, vec3(1.0, 0.9, 0.8), smoothstep(0.4, 1.0, temp));

                float beaming = 1.0 + vDoppler * 0.7;
                float edgeFade = 1.0 - smoothstep(15.0, 24.0, vRadius);

                gl_FragColor = vec4(color * beaming * uParticleBrightness, alpha * edgeFade * passMask);
            }
        `;

        const particleUniforms = {
            uTime: { value: 0 },
            uSpinSpeed: { value: 0.1 },
            uCameraPos: { value: camera.position.clone() },
            uRadiusLimit: { value: 2.0 },
            uParticleBrightness: { value: 3.0 },
            uResolution: { value: new THREE.Vector2(renderer.domElement.width, renderer.domElement.height) },
            uLensCenter: { value: new THREE.Vector2(0.5, 0.5) },
            uLensRadius: { value: 0.1 },
            uLensStrength: { value: 1.0 },
            uAspectRatio: { value: window.innerWidth / window.innerHeight }
        };

        const pMatBack = new THREE.ShaderMaterial({
            uniforms: { ...particleUniforms, uIsFront: { value: 0.0 } },
            vertexShader: particleVertexShader,
            fragmentShader: particleFragmentShader,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        const pMatFront = new THREE.ShaderMaterial({
            uniforms: { ...particleUniforms, uIsFront: { value: 1.0 } },
            vertexShader: particleVertexShader,
            fragmentShader: particleFragmentShader,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });
        pMatFront.depthTest = false;

        sceneParticlesBack.add(new THREE.Points(particleGeo, pMatBack));
        sceneParticlesFront.add(new THREE.Points(particleGeo, pMatFront));

        // --- 5. DYNAMIC GRAVITATIONAL LENSING SHADER ---
        const LensingShader = {
            uniforms: {
                tDiffuse: { value: null },
                center: { value: new THREE.Vector2(0.5, 0.5) },
                radius: { value: 0.1 },
                strength: { value: 1.0 },
                aspectRatio: { value: window.innerWidth / window.innerHeight },
                uCameraPos: { value: camera.position.clone() }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform vec2 center;
                uniform float radius;
                uniform float strength;
                uniform float aspectRatio;
                uniform vec3 uCameraPos;
                varying vec2 vUv;

                void main() {
                    vec2 uv = vUv;
                    vec2 delta = uv - center;
                    delta.x *= aspectRatio;
                    float dist = length(delta);

                    float viewAngle = abs(normalize(uCameraPos).y);
                    float effectiveStrength = strength * (1.0 - viewAngle * 0.85);
                    float safeDist = max(dist, 0.0001);
                    float deflection = effectiveStrength * (radius * radius) / max(safeDist, radius * 0.08);
                    float sourceDist = dist - deflection;

                    vec2 dir = delta / safeDist;
                    vec2 distortedUv = center + dir * sourceDist * vec2(1.0 / aspectRatio, 1.0);

                    vec4 texColor = texture2D(tDiffuse, clamp(distortedUv, 0.0, 1.0));
                    gl_FragColor = texColor;
                }
            `
        };

        // --- 6. PIPELINE ---
        const composer = new EffectComposer(renderer);

        const roomPass = new RenderPass(sceneRoom, camera);
        roomPass.clearColor = new THREE.Color(0x000000);
        roomPass.clearAlpha = 1.0;
        composer.addPass(roomPass);

        const raymarchPass = new RenderPass(sceneRaymarch, orthoCamera);
        raymarchPass.clear = false;
        composer.addPass(raymarchPass);

        const particleBackPass = new RenderPass(sceneParticlesBack, camera);
        particleBackPass.clear = false;
        composer.addPass(particleBackPass);

        const lensingPass = new ShaderPass(LensingShader);
        lensingPass.material.depthTest = false;
        lensingPass.material.depthWrite = false;
        composer.addPass(lensingPass);

        const particleFrontPass = new RenderPass(sceneParticlesFront, camera);
        particleFrontPass.clear = false;
        particleFrontPass.clearDepth = true;
        composer.addPass(particleFrontPass);

        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.8, 0.5, 0.85);
        bloomPass.threshold = 0.2;
        composer.addPass(bloomPass);

        // --- 7. CONTROLS & RENDER LOOP ---
        const gui = new GUI({ title: 'Black Hole Physics' });
        const params = {
            spinSpeed: 0.1,
            lensStrength: 1.0,
            diskBrightness: 4.0,
            particleBrightness: 3.0,
            showParticles: true,
            radius: 2.0,
            autoOrbit: false,
            expand: () => triggerExpansion()
        };
        gui.add(params, 'spinSpeed', 0.0, 2.0).name('Time Scale');
        gui.add(params, 'lensStrength', 0.0, 3.5).name('Lensing Strength');
        gui.add(params, 'diskBrightness', 0.0, 15.0).name('Core Brightness');
        gui.add(params, 'particleBrightness', 0.0, 6.0).name('Gas Brightness');
        gui.add(params, 'showParticles').name('Show Particles').onChange((enabled) => {
            particleBackPass.enabled = enabled;
            particleFrontPass.enabled = enabled;
        });
        gui.add(params, 'radius', 1.0, 8.0).name('Black Hole Mass').listen();
        gui.add(params, 'autoOrbit').name('Auto Camera Orbit');
        gui.add(params, 'expand').name('Simulate Growth');

        let isExpanding = false;
        let expansionTime = 0;
        let currentScale = 1.0;

        function triggerExpansion() {
            if(isExpanding) return;
            isExpanding = true;
            expansionTime = 0;
            currentScale = 0.1;
        }

        const clock = new THREE.Clock();
        const cameraMat = new THREE.Matrix4();
        const bhWorldPos = new THREE.Vector3();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            if (params.autoOrbit) {
                // Slowly pan the camera around the black hole automatically
                camera.position.x = Math.cos(time * 0.1) * 35;
                camera.position.z = Math.sin(time * 0.1) * 35;
                camera.lookAt(0, 0, 0);
            }
            controls.update();

            cameraMat.extractRotation(camera.matrixWorld);
            
            raymarchMat.uniforms.uCameraPos.value.copy(camera.position);
            raymarchMat.uniforms.uCameraMatrix.value.copy(cameraMat);
            raymarchMat.uniforms.uTime.value = time;
            raymarchMat.uniforms.uSpinSpeed.value = params.spinSpeed;
            raymarchMat.uniforms.uLensStrength.value = params.lensStrength;
            raymarchMat.uniforms.uDiskBrightness.value = params.diskBrightness;
            diskLight.intensity = params.diskBrightness * 4500.0;

            [pMatBack, pMatFront].forEach((mat) => {
                mat.uniforms.uCameraPos.value.copy(camera.position);
                mat.uniforms.uTime.value = time;
                mat.uniforms.uSpinSpeed.value = params.spinSpeed;
                mat.uniforms.uParticleBrightness.value = params.particleBrightness;
            });

            if (isExpanding) {
                expansionTime += delta;
                const progress = Math.min(expansionTime / 3.0, 1.0);
                const easeOut = 1 - Math.pow(1 - progress, 3);
                currentScale = 0.1 + (easeOut * 0.9); 
                params.radius = 3.0 * currentScale; // Updates UI
                if (progress >= 1.0) isExpanding = false;
            }

            raymarchMat.uniforms.uRadiusLimit.value = params.radius;
            pMatBack.uniforms.uRadiusLimit.value = params.radius;
            pMatFront.uniforms.uRadiusLimit.value = params.radius;

            lensingPass.uniforms.uCameraPos.value.copy(camera.position);
            lensingPass.uniforms.strength.value = params.lensStrength;

            bhWorldPos.set(0, 0, 0).project(camera);
            lensingPass.uniforms.center.value.set((bhWorldPos.x + 1) * 0.5, (bhWorldPos.y + 1) * 0.5);

            const dist = camera.position.length();
            const vFOV = THREE.MathUtils.degToRad(camera.fov);
            const viewHeight = 2 * Math.tan(vFOV * 0.5) * dist;
            lensingPass.uniforms.radius.value = params.radius / Math.max(viewHeight, 0.0001);

            [pMatBack, pMatFront].forEach((mat) => {
                mat.uniforms.uLensCenter.value.copy(lensingPass.uniforms.center.value);
                mat.uniforms.uLensRadius.value = lensingPass.uniforms.radius.value;
                mat.uniforms.uLensStrength.value = params.lensStrength;
                mat.uniforms.uAspectRatio.value = lensingPass.uniforms.aspectRatio.value;
            });

            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            raymarchMat.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
            lensingPass.uniforms.aspectRatio.value = window.innerWidth / window.innerHeight;
            pMatBack.uniforms.uResolution.value.set(renderer.domElement.width, renderer.domElement.height);
            pMatFront.uniforms.uResolution.value.set(renderer.domElement.width, renderer.domElement.height);
            pMatBack.uniforms.uAspectRatio.value = window.innerWidth / window.innerHeight;
            pMatFront.uniforms.uAspectRatio.value = window.innerWidth / window.innerHeight;
        });

        animate();
    </script>
</body>
</html>
