<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realistic Black Hole Prototype</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #info {
            position: absolute; top: 10px; left: 10px; color: rgba(255,255,255,0.8);
            background: rgba(0,0,0,0.5); padding: 15px; border-radius: 8px;
            pointer-events: none; border: 1px solid rgba(255,255,255,0.2);
            z-index: 100;
        }
        h1 { margin: 0 0 5px 0; font-size: 18px; color: #ff9d00; }
        p { margin: 0; font-size: 12px; }
    </style>
</head>
<body>
    <div id="info">
        <h1>Hybrid Ray-Marching Engine</h1>
        <p>Real Relativistic Physics Applied:</p>
        <p>- Pure Mathematical Light Bending</p>
        <p>- 3D Volumetric Particle Swarm</p>
        <p>- Event Horizon Shadow Occlusion</p>
        <p>- Raytraced Environment</p>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.156.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.156.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- 1. CORE SETUP ---
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 8, 35);

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2; 
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 10;
        controls.maxDistance = 90;

        // --- 2. HYBRID SCENE ARCHITECTURE ---
        const sceneRaymarch = new THREE.Scene();  // Keep Gemini black-hole/lensing core
        const sceneBack = new THREE.Scene();      // Old-style back layer for wrap-around
        const sceneFront = new THREE.Scene();     // Old-style front layer for wrap-around

        const orthoCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        const DISK_LAYER_ALPHA_BASE = 1.0 / 8.0;
        const sharedUniforms = {
            uTime: { value: 0 },
            uSpinSpeed: { value: 0.05 },
            uCameraPos: { value: camera.position.clone() },
            uRadiusLimit: { value: 5.0 },
            uLayerAlpha: { value: DISK_LAYER_ALPHA_BASE },
            uCoreBrightness: { value: 0.2 },
            uLensCenter: { value: new THREE.Vector2(0.5, 0.5) },
            uLensRadius: { value: 0.1 },
            uAspectRatio: { value: window.innerWidth / window.innerHeight },
            uViewport: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
            uFrontCoreMaskScale: { value: 0.98 }
        };

        // --- 3. LAYER 1: GENERAL RELATIVITY RAYMARCHER ---
        const raymarchVertexShader = `
            varying vec2 vUv;
            void main() { vUv = uv; gl_Position = vec4(position, 1.0); }
        `;

        const raymarchFragmentShader = `
            uniform vec3 uCameraPos;
            uniform mat4 uCameraMatrix;
            uniform vec2 uResolution;
            uniform float uTime;
            uniform float uSpinSpeed;
            uniform float uRadiusLimit;
            uniform float uDiskBrightness;
            uniform float uLensStrength;
            uniform float uGravityK;
            uniform float uHorizonHit;
            uniform float uEscapeRadius;
            uniform int uMaxSteps;
            uniform float uStepScale;
            uniform float uEquatorClampEnabled;
            uniform float uEquatorBand;
            uniform float uEquatorRadius;
            uniform float uEquatorStepMin;
            uniform float uEquatorStepScale;
            uniform float uNearHorizonFallback;
            uniform float uDebugTerminationMode;

            varying vec2 vUv;

            float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
            float noise(vec2 st) {
                vec2 i = floor(st); vec2 f = fract(st);
                float a = random(i); float b = random(i + vec2(1.0, 0.0));
                float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0));
                vec2 u = f * f * (3.0 - 2.0 * f);
                return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
            }
            float fbm(vec2 st) {
                float value = 0.0; float amp = 0.5;
                for (int i = 0; i < 4; i++) {
                    value += amp * noise(st); st *= 2.0; amp *= 0.5;
                }
                return value;
            }

            void main() {
                vec2 uv = (vUv - 0.5) * 2.0;
                uv.x *= uResolution.x / uResolution.y;

                float fov = tan(45.0 * 0.5 * 3.14159 / 180.0);
                vec3 rayDir = normalize(vec3(uv.x * fov, uv.y * fov, -1.0));
                rayDir = (uCameraMatrix * vec4(rayDir, 0.0)).xyz;
                vec3 roomDir = rayDir;
                
                vec3 rayPos = uCameraPos;
                
                float rs = uRadiusLimit;
                float horizonRadius = rs * uHorizonHit;
                vec3 h = cross(rayPos, rayDir);
                float h2 = dot(h, h);
                
                vec4 color = vec4(0.0);
                float dt = 0.05;
                bool hitHorizon = false;
                int termReason = 0; // 1 = horizon hit, 2 = escaped, 3 = max-step/unfinished
                
                const int MAX_RAYMARCH_STEPS = 1200;
                for(int i = 0; i < MAX_RAYMARCH_STEPS; i++) {
                    if(i >= uMaxSteps) { termReason = 3; break; }
                    float r2 = dot(rayPos, rayPos);
                    float r = sqrt(r2);
                    
                    if(r < horizonRadius) { hitHorizon = true; termReason = 1; break; }
                    if(r > uEscapeRadius) { termReason = 2; break; }
                    
                    vec3 accel = -uGravityK * uLensStrength * h2 * rs * rayPos / (r2 * r2 * r);
                    rayDir = normalize(rayDir + accel * dt);
                    
                    float r_xz = length(rayPos.xz);
                    
                    // CRITICAL FIX: Add the ISCO (Innermost Stable Circular Orbit) gap
                    float isco = rs * 1.35;
                    
                    // Disk visuals come from layered plasma meshes below; keep raymarch for BH/lensing.
                    if(false && r_xz > isco && r_xz < 28.0) {
                        float scaleHeight = 0.03 * rs + pow(max(0.0, r_xz - isco)/15.0, 2.0) * 0.25;
                        float yDist = abs(rayPos.y);
                        float verticalFade = exp(-yDist * yDist / (scaleHeight * scaleHeight));
                        
                        if(verticalFade > 0.01) {
                            float omega = (2.0 * uSpinSpeed) * pow(isco / r_xz, 0.65);
                            float angle = atan(rayPos.z, rayPos.x) + uTime * omega;
                            
                            vec2 p2 = vec2(cos(angle)*r_xz, sin(angle)*r_xz) * 0.4;
                            vec2 w = vec2(fbm(p2 + vec2(2.1, 5.7)), fbm(p2 + vec2(8.3, 1.3)));
                            float gas = fbm(p2 * 1.5 + w * 2.0 - uTime * 0.15);
                            
                            float isInner = 1.0 - smoothstep(isco, isco + 1.5, r_xz);
                            float density = mix(smoothstep(0.2, 0.8, gas), 1.0, isInner) * verticalFade;
                            density *= 1.0 - smoothstep(18.0, 28.0, r_xz); 
                            
                            float temp = pow(isco / r_xz, 1.4);
                            vec3 c = mix(vec3(0.6, 0.05, 0.0), vec3(1.0, 0.4, 0.0), smoothstep(0.0, 0.3, temp));
                            c = mix(c, vec3(1.0, 0.85, 0.3), smoothstep(0.3, 0.7, temp));
                            c = mix(c, vec3(1.0, 1.0, 1.0), smoothstep(0.7, 1.0, temp));
                            
                            vec3 velDir = normalize(vec3(-rayPos.z, 0.0, rayPos.x));
                            float doppler = dot(-rayDir, velDir); 
                            
                            // CRITICAL FIX: Tone down the explosive relativistic math to stop the right side from blowing out
                            float beaming = 1.0 + doppler * 0.8; 
                            
                            vec3 em = c * beaming * uDiskBrightness * density;
                            float alpha = density * dt * 3.5;
                            
                            color.rgb += (1.0 - color.a) * em * dt;
                            color.a += (1.0 - color.a) * alpha;
                            
                            if(color.a > 0.99) break;
                        }
                    }
                    
                    dt = uStepScale * r;
                    float distToEquator = abs(rayPos.y);
                    if(uEquatorClampEnabled > 0.5 && distToEquator < uEquatorBand && r_xz < uEquatorRadius) {
                        dt = min(dt, max(uEquatorStepMin, distToEquator * uEquatorStepScale));
                    }

                    // Robust horizon hit: prevent stepping over the sphere at shallow grazing angles.
                    vec3 nextPos = rayPos + rayDir * dt;
                    vec3 seg = nextPos - rayPos;
                    float a = dot(seg, seg);
                    if (a > 1e-8) {
                        // Use closest approach on the segment to also catch tangent/near-tangent hits.
                        float tClosest = clamp(-dot(rayPos, seg) / a, 0.0, 1.0);
                        vec3 pClosest = rayPos + seg * tClosest;
                        if (dot(pClosest, pClosest) <= horizonRadius * horizonRadius) {
                            hitHorizon = true;
                            termReason = 1;
                            break;
                        }
                    }
                    rayPos = nextPos;
                }

                // If the loop maxes out but the ray endpoint is still near the horizon, classify as a hit.
                if(termReason == 0) termReason = 3;
                if(termReason == 3) {
                    float rEnd = length(rayPos);
                    if(rEnd <= horizonRadius * uNearHorizonFallback) {
                        hitHorizon = true;
                        termReason = 1;
                    }
                }

                if(uDebugTerminationMode > 0.5) {
                    vec3 dbg = vec3(1.0, 0.0, 1.0);
                    if(termReason == 1) dbg = vec3(0.0, 0.0, 0.0);      // horizon hit
                    if(termReason == 2) dbg = vec3(0.0, 0.7, 1.0);      // escaped to room
                    if(termReason == 3) dbg = vec3(1.0, 0.0, 0.0);      // max-step/unfinished
                    gl_FragColor = vec4(dbg, 1.0);
                    return;
                }
                
                if(color.a < 0.99) {
                    // Use original camera ray for room projection; post lens pass handles visible bending.
                    vec3 absDir = abs(roomDir);
                    float maxAxis = max(max(absDir.x, absDir.y), absDir.z);
                    vec3 boxPos = roomDir / maxAxis * uEscapeRadius;
                    
                    vec2 uvBox;
                    if(maxAxis == absDir.y) uvBox = boxPos.xz;
                    else if(maxAxis == absDir.x) uvBox = boxPos.yz;
                    else uvBox = boxPos.xy;
                    
                    vec2 grid = fract(uvBox * 0.15);
                    float line = step(0.96, grid.x) + step(0.96, grid.y);
                    vec3 roomCol = mix(vec3(0.015, 0.015, 0.02), vec3(0.0), clamp(line, 0.0, 1.0));
                    
                    float dist = length(boxPos);
                    float diskDrive = pow(max(uDiskBrightness, 0.0), 0.65);
                    roomCol += vec3(1.0, 0.5, 0.1) * (150.0 * rs / (dist * dist)) * (0.08 + 0.12 * diskDrive);

                    color.rgb += (1.0 - color.a) * roomCol;
                }
                
                gl_FragColor = vec4(color.rgb, 1.0);
            }
        `;

        const raymarchMat = new THREE.ShaderMaterial({
            uniforms: {
                uCameraPos: { value: new THREE.Vector3() },
                uCameraMatrix: { value: new THREE.Matrix4() },
                uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                uTime: { value: 0 },
                uSpinSpeed: { value: 1.0 },
                uRadiusLimit: { value: 5.0 },
                uDiskBrightness: { value: 0.2 },
                uLensStrength: { value: 0.5 },
                uGravityK: { value: 1.5 },
                uHorizonHit: { value: 0.98 },
                uEscapeRadius: { value: 150.0 },
                uMaxSteps: { value: 600 },
                uStepScale: { value: 0.04 },
                uEquatorClampEnabled: { value: 0.0 },
                uEquatorBand: { value: 0.0 },
                uEquatorRadius: { value: 30.0 },
                uEquatorStepMin: { value: 0.015 },
                uEquatorStepScale: { value: 0.3 },
                uNearHorizonFallback: { value: 1.03 },
                uDebugTerminationMode: { value: 0.0 }
            },
            vertexShader: raymarchVertexShader,
            fragmentShader: raymarchFragmentShader,
            depthWrite: false
        });

        const quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), raymarchMat);
        sceneRaymarch.add(quad);


        // --- 4. LAYER 2: OLD-STYLE ACCRETION DISK + WRAPPED PARTICLES ---
        const plasmaVertexShader = `
            varying vec3 vWorldPosition;
            void main() {
                vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                gl_Position = projectionMatrix * viewMatrix * vec4(vWorldPosition, 1.0);
            }
        `;

        const plasmaFragmentShader = `
            uniform float uTime;
            uniform float uSpinSpeed;
            uniform vec3 uCameraPos;
            uniform float uRadiusLimit;
            uniform float uIsFront;
            uniform float uLayerAlpha;
            uniform float uCoreBrightness;
            uniform vec2 uLensCenter;
            uniform float uLensRadius;
            uniform float uAspectRatio;
            uniform vec2 uViewport;
            uniform float uFrontCoreMaskScale;

            varying vec3 vWorldPosition;

            float random(in vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
            float noise(in vec2 st) {
                vec2 i = floor(st); vec2 f = fract(st);
                float a = random(i); float b = random(i + vec2(1.0, 0.0));
                float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0));
                vec2 u = f * f * (3.0 - 2.0 * f);
                return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
            }
            float fbm(vec2 st) {
                float value = 0.0; float amp = 0.5;
                for (int i = 0; i < 4; i++) {
                    value += amp * noise(st); st *= 2.0; amp *= 0.5;
                }
                return value;
            }

            void main() {
                vec3 bhToPixel = vWorldPosition;
                vec3 camDir = normalize(vec3(0.0) - uCameraPos);
                float pixelDepth = dot(bhToPixel, camDir);

                // Match old behavior: render full disk in both passes.
                // The back pass is lensed; the front pass overlays, producing the wrap illusion.
                float passMask = 1.0;
                float backMask = smoothstep(-0.12, 0.12, pixelDepth);

                // Prevent front-pass emission from leaking into the black-hole core.
                if (uIsFront > 0.5) {
                    vec2 screenUv = gl_FragCoord.xy / uViewport;
                    vec2 coreDelta = screenUv - uLensCenter;
                    coreDelta.x *= uAspectRatio;
                    if (length(coreDelta) < uLensRadius * uFrontCoreMaskScale && backMask > 0.55) discard;
                }

                float r = length(vWorldPosition.xz);
                float innerEdge = uRadiusLimit + 0.1;
                if (r < innerEdge || r > 14.0) discard;

                float effR = max(r, uRadiusLimit);
                float temp = pow(uRadiusLimit / effR, 1.8);
                vec3 color = mix(vec3(0.5, 0.05, 0.0), vec3(1.0, 0.3, 0.0), smoothstep(0.0, 0.3, temp));
                color = mix(color, vec3(1.0, 0.8, 0.2), smoothstep(0.3, 0.7, temp));
                color = mix(color, vec3(1.0, 1.0, 1.0), smoothstep(0.7, 1.0, temp));

                float angle = atan(vWorldPosition.z, vWorldPosition.x);
                vec3 velocityDir = normalize(vec3(-sin(angle), 0.0, cos(angle)));
                vec3 viewDir = normalize(uCameraPos - vWorldPosition);
                float doppler = dot(velocityDir, viewDir);
                float beaming = 1.0 + doppler * 0.7;

                float omega = (2.0 * uSpinSpeed) * pow(uRadiusLimit / effR, 0.65);
                float c = cos(uTime * omega);
                float s = sin(uTime * omega);
                mat2 rot = mat2(c, s, -s, c);

                vec2 p = rot * (vWorldPosition.xz * 0.28);
                vec2 w = vec2(fbm(p + vec2(2.1, 5.7)), fbm(p + vec2(8.3, 1.3)));
                p += (w - 0.5) * 2.2;

                float gas = fbm(p * 1.7 + vec2(0.0, uTime * 0.12));
                float density = mix(0.1, 1.0, smoothstep(0.3, 0.8, gas));

                float photonRing = 1.0 - smoothstep(uRadiusLimit, uRadiusLimit + 0.3, r);
                float coreDrive = pow(max(uCoreBrightness, 0.0), 0.68);
                float radialFalloff = mix(1.0, 0.35, smoothstep(uRadiusLimit + 0.2, 12.0, r));
                vec3 finalColor = (color * beaming * 1.25) + (vec3(1.0, 0.9, 0.6) * photonRing * 2.1);
                finalColor *= coreDrive * radialFalloff;

                float outerFade = 1.0 - smoothstep(10.0, 14.0, r);
                float viewAngle = abs(normalize(uCameraPos).y);
                float edgeBoost = 1.0 + (1.0 - viewAngle) * 1.5;

                float alpha = outerFade * density * 1.2 * uLayerAlpha * passMask * edgeBoost;
                gl_FragColor = vec4(finalColor, alpha);
            }
        `;

        const plasmaGeo = new THREE.PlaneGeometry(30, 30);
        const plasmaMatBack = new THREE.ShaderMaterial({
            uniforms: { ...sharedUniforms, uLayerAlpha: { value: DISK_LAYER_ALPHA_BASE }, uIsFront: { value: 0.0 } },
            vertexShader: plasmaVertexShader,
            fragmentShader: plasmaFragmentShader,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            side: THREE.DoubleSide
        });
        const plasmaMatFront = new THREE.ShaderMaterial({
            uniforms: { ...sharedUniforms, uLayerAlpha: { value: DISK_LAYER_ALPHA_BASE }, uIsFront: { value: 1.0 } },
            vertexShader: plasmaVertexShader,
            fragmentShader: plasmaFragmentShader,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            side: THREE.DoubleSide
        });
        plasmaMatFront.depthTest = false;

        const DISK_LAYERS = 8;
        const DISK_THICKNESS = 0.25;
        for (let i = 0; i < DISK_LAYERS; i++) {
            const t = i / (DISK_LAYERS - 1);
            const y = THREE.MathUtils.lerp(-DISK_THICKNESS * 0.5, DISK_THICKNESS * 0.5, t);

            const b = new THREE.Mesh(plasmaGeo, plasmaMatBack);
            b.rotation.x = -Math.PI / 2;
            b.position.y = y;
            sceneBack.add(b);

            const f = new THREE.Mesh(plasmaGeo, plasmaMatFront);
            f.rotation.x = -Math.PI / 2;
            f.position.y = y;
            sceneFront.add(f);
        }

        const particleCount = 60000;
        const particlePositions = new Float32Array(particleCount * 3);
        const particleAngles = new Float32Array(particleCount);
        const particleRadii = new Float32Array(particleCount);
        const particleSizes = new Float32Array(particleCount);

        for (let i = 0; i < particleCount; i++) {
            const r = Math.pow(Math.random(), 1.5) * 24.0;
            const theta = Math.random() * Math.PI * 2;
            const edgeCone = 1.0 - THREE.MathUtils.smoothstep(r, 17.0, 24.0);

            particleRadii[i] = r;
            particleAngles[i] = theta;
            particleSizes[i] = (Math.random() * 1.4 + 0.45) * (r / 10.0) * (0.55 + 0.45 * edgeCone);

            particlePositions[i * 3] = r * Math.cos(theta);
            const baseSpread = Math.pow(Math.max(0.0, r - 3.0) / 15.0, 1.6) * 1.8;
            const verticalSpread = baseSpread * (0.25 + 0.75 * edgeCone);
            particlePositions[i * 3 + 1] = (Math.random() - 0.5) * verticalSpread;
            particlePositions[i * 3 + 2] = r * Math.sin(theta);
        }

        const particleGeo = new THREE.BufferGeometry();
        particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        particleGeo.setAttribute('aAngle', new THREE.BufferAttribute(particleAngles, 1));
        particleGeo.setAttribute('aRadius', new THREE.BufferAttribute(particleRadii, 1));
        particleGeo.setAttribute('aSize', new THREE.BufferAttribute(particleSizes, 1));

        const particleVertexShader = `
            uniform float uTime;
            uniform float uSpinSpeed;
            uniform vec3 uCameraPos;
            uniform float uRadiusLimit;
            uniform float uParticleOrbitMul;
            uniform float uParticleVerticalScale;
            uniform float uParticleJitterAmp;
            uniform float uParticleJitterFreq;
            uniform float uParticleSizeMul;
            uniform float uParticleConeStart;
            uniform float uParticleConeEnd;
            uniform float uParticleConeMin;

            attribute float aAngle;
            attribute float aRadius;
            attribute float aSize;

            varying float vDoppler;
            varying float vRadius;
            varying float vPixelDepth;
            varying vec3 vWorldPosition;

            void main() {
                vRadius = aRadius;
                float effR = max(aRadius, uRadiusLimit);
                float speed = (18.0 / sqrt(effR)) * uParticleOrbitMul;
                float currentAngle = aAngle + (uTime * speed * uSpinSpeed);
                float edgeCone = 1.0 - smoothstep(uParticleConeStart, uParticleConeEnd, aRadius);
                float coneScale = mix(uParticleConeMin, 1.0, edgeCone);

                vec3 newPos = position;
                newPos.x = aRadius * cos(currentAngle);
                newPos.z = aRadius * sin(currentAngle);
                newPos.y = position.y * uParticleVerticalScale * coneScale;
                newPos.y += sin(uTime * uParticleJitterFreq + aAngle * 10.0) * uParticleJitterAmp * coneScale;

                vec4 worldPosition = modelMatrix * vec4(newPos, 1.0);
                vWorldPosition = worldPosition.xyz;

                vec3 bhToPixel = worldPosition.xyz;
                vec3 camDir = normalize(vec3(0.0) - uCameraPos);
                vPixelDepth = dot(bhToPixel, camDir);

                vec3 velocityDir = normalize(vec3(-sin(currentAngle), 0.0, cos(currentAngle)));
                vec3 viewDir = normalize(uCameraPos - worldPosition.xyz);
                vDoppler = dot(velocityDir, viewDir);

                vec4 mvPosition = viewMatrix * worldPosition;
                gl_PointSize = (aSize * 90.0 * uParticleSizeMul) / -mvPosition.z;
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const particleFragmentShader = `
            uniform float uRadiusLimit;
            uniform float uIsFront;
            uniform vec3 uCameraPos;
            uniform float uParticleBrightness;
            uniform float uCoreBrightness;
            uniform float uInnerCutoff;
            uniform float uInnerFadeStart;
            uniform float uInnerFadeEnd;
            uniform float uParticleAlpha;
            uniform float uParticleSoftness;
            uniform float uParticleEdgeStart;
            uniform float uParticleEdgeEnd;
            uniform float uParticleEdgePow;
            uniform float uParticleBeaming;
            uniform float uParticleTempPow;
            uniform float uParticleCoreGamma;
            uniform float uParticleConeStart;
            uniform float uParticleConeEnd;
            uniform float uParticleConeMin;
            uniform vec3 uParticleColorLow;
            uniform vec3 uParticleColorMid;
            uniform vec3 uParticleColorHigh;
            uniform vec2 uLensCenter;
            uniform float uLensRadius;
            uniform float uAspectRatio;
            uniform vec2 uViewport;
            uniform float uFrontCoreMaskScale;

            varying float vDoppler;
            varying float vRadius;
            varying float vPixelDepth;
            varying vec3 vWorldPosition;

            void main() {
                // Match old behavior: render full particle set in both passes.
                float passMask = 1.0;
                if (vRadius < uRadiusLimit + uInnerCutoff) discard;
                float backMask = smoothstep(-0.12, 0.12, vPixelDepth);
                if (uIsFront > 0.5) {
                    vec2 screenUv = gl_FragCoord.xy / uViewport;
                    vec2 coreDelta = screenUv - uLensCenter;
                    coreDelta.x *= uAspectRatio;
                    if (length(coreDelta) < uLensRadius * uFrontCoreMaskScale && backMask > 0.55) discard;
                }

                vec2 coord = gl_PointCoord - vec2(0.5);
                float dist = length(coord);
                if (dist > 0.5) discard;
                float alpha = exp(-dist * dist * uParticleSoftness) * uParticleAlpha;

                float effR = max(vRadius, uRadiusLimit);
                float temp = pow(uRadiusLimit / effR, uParticleTempPow);
                vec3 color = mix(uParticleColorLow, uParticleColorMid, smoothstep(0.0, 0.4, temp));
                color = mix(color, uParticleColorHigh, smoothstep(0.4, 1.0, temp));

                float beaming = 1.0 + vDoppler * uParticleBeaming;
                float edgeFade = pow(1.0 - smoothstep(uParticleEdgeStart, uParticleEdgeEnd, vRadius), uParticleEdgePow);
                float innerFade = smoothstep(uRadiusLimit + uInnerFadeStart, uRadiusLimit + uInnerFadeEnd, vRadius);
                float coneTaper = 1.0 - smoothstep(uParticleConeStart, uParticleConeEnd, vRadius);
                float coreDrive = pow(max(uCoreBrightness, 0.0), uParticleCoreGamma);
                float taperBoost = mix(uParticleConeMin, 1.0, coneTaper);
                gl_FragColor = vec4(color * beaming * uParticleBrightness * coreDrive * taperBoost, alpha * edgeFade * passMask * innerFade * taperBoost);
            }
        `;

        const pMatBack = new THREE.ShaderMaterial({
            uniforms: {
                ...sharedUniforms,
                uParticleBrightness: { value: 3.0 },
                uInnerCutoff: { value: 0.08 },
                uInnerFadeStart: { value: 0.12 },
                uInnerFadeEnd: { value: 0.9 },
                uParticleAlpha: { value: 0.18 },
                uParticleSoftness: { value: 12.0 },
                uParticleEdgeStart: { value: 14.5 },
                uParticleEdgeEnd: { value: 24.0 },
                uParticleEdgePow: { value: 1.8 },
                uParticleBeaming: { value: 0.7 },
                uParticleTempPow: { value: 0.5 },
                uParticleCoreGamma: { value: 0.62 },
                uParticleOrbitMul: { value: 1.0 },
                uParticleVerticalScale: { value: 2.0 },
                uParticleJitterAmp: { value: 0.15 },
                uParticleJitterFreq: { value: 1.5 },
                uParticleSizeMul: { value: 1.0 },
                uParticleConeStart: { value: 17.0 },
                uParticleConeEnd: { value: 20.0 },
                uParticleConeMin: { value: 0.55 },
                uParticleColorLow: { value: new THREE.Color(0.6, 0.1, 0.0) },
                uParticleColorMid: { value: new THREE.Color(1.0, 0.5, 0.1) },
                uParticleColorHigh: { value: new THREE.Color(1.0, 0.9, 0.8) },
                uIsFront: { value: 0.0 }
            },
            vertexShader: particleVertexShader,
            fragmentShader: particleFragmentShader,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });
        const pMatFront = new THREE.ShaderMaterial({
            uniforms: {
                ...sharedUniforms,
                uParticleBrightness: { value: 3.0 },
                uInnerCutoff: { value: 0.08 },
                uInnerFadeStart: { value: 0.12 },
                uInnerFadeEnd: { value: 0.9 },
                uParticleAlpha: { value: 0.18 },
                uParticleSoftness: { value: 12.0 },
                uParticleEdgeStart: { value: 14.5 },
                uParticleEdgeEnd: { value: 24.0 },
                uParticleEdgePow: { value: 1.8 },
                uParticleBeaming: { value: 0.7 },
                uParticleTempPow: { value: 0.5 },
                uParticleCoreGamma: { value: 0.62 },
                uParticleOrbitMul: { value: 1.0 },
                uParticleVerticalScale: { value: 2.0 },
                uParticleJitterAmp: { value: 0.15 },
                uParticleJitterFreq: { value: 1.5 },
                uParticleSizeMul: { value: 1.0 },
                uParticleConeStart: { value: 17.0 },
                uParticleConeEnd: { value: 20.0 },
                uParticleConeMin: { value: 0.55 },
                uParticleColorLow: { value: new THREE.Color(0.6, 0.1, 0.0) },
                uParticleColorMid: { value: new THREE.Color(1.0, 0.5, 0.1) },
                uParticleColorHigh: { value: new THREE.Color(1.0, 0.9, 0.8) },
                uIsFront: { value: 1.0 }
            },
            vertexShader: particleVertexShader,
            fragmentShader: particleFragmentShader,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });
        pMatFront.depthTest = false;

        const backParticles = new THREE.Points(particleGeo, pMatBack);
        const frontParticles = new THREE.Points(particleGeo, pMatFront);
        sceneBack.add(backParticles);
        sceneFront.add(frontParticles);

        const particleParams = {
            density: 1.0,
            sizeMul: 4.0,
            alpha: 0.03,
            softness: 5.0,
            orbitMul: 1.0,
            verticalScale: 2.0,
            jitterAmp: 0.0,
            jitterFreq: 0.0,
            coneStart: 5.0,
            coneEnd: 20.0,
            coneMin: 0.0,
            edgeStart: 8.0,
            edgeEnd: 18.0,
            edgePow: 0.5,
            beaming: 0.0,
            tempPow: 0.5,
            coreGamma: 0.5,
            innerCutoff: 0.0,
            innerFadeStart: 0.0,
            innerFadeEnd: 0.0,
            colorLow: '#993300',
            colorMid: '#ff7f1a',
            colorHigh: '#ffe6cc'
        };

        // --- 5. POST LENSING PASS (back layer only) ---
        const LensingShader = {
            uniforms: {
                tDiffuse: { value: null },
                center: { value: new THREE.Vector2(0.5, 0.5) },
                radius: { value: 0.1 },
                strength: { value: 0.5 },
                aspectRatio: { value: window.innerWidth / window.innerHeight },
                uCameraPos: { value: camera.position.clone() },
                uCoreBrightness: { value: 0.2 },
                uCenterPreserve: { value: 0.98 },
                uViewDamp: { value: 0.85 },
                uHorizonAbsorbStart: { value: 0.90 },
                uHorizonAbsorbEnd: { value: 0.98 },
                uHorizonAbsorbAmount: { value: 0.0 },
                uRingStart: { value: 0.98 },
                uRingEnd: { value: 1.05 },
                uRingIntensity: { value: 1.5 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform vec2 center;
                uniform float radius;
                uniform float strength;
                uniform float aspectRatio;
                uniform vec3 uCameraPos;
                uniform float uCoreBrightness;
                uniform float uCenterPreserve;
                uniform float uViewDamp;
                uniform float uHorizonAbsorbStart;
                uniform float uHorizonAbsorbEnd;
                uniform float uHorizonAbsorbAmount;
                uniform float uRingStart;
                uniform float uRingEnd;
                uniform float uRingIntensity;
                varying vec2 vUv;

                void main() {
                    vec2 uv = vUv;
                    vec2 delta = uv - center;
                    delta.x *= aspectRatio;
                    float dist = length(delta);
                    float safeDist = max(dist, 0.0001);
                    vec4 baseColor = texture2D(tDiffuse, uv);

                    // Black-hole core is authored only here (not from raymarch background).
                    if (dist < radius * uCenterPreserve) {
                        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                        return;
                    }

                    float viewAngle = abs(normalize(uCameraPos).y);
                    float effectiveStrength = strength * (1.0 - viewAngle * uViewDamp);
                    float deflection = effectiveStrength * (radius * radius) / safeDist;
                    float sourceDist = dist - deflection;

                    vec2 dir = delta / safeDist;
                    vec2 distortedUv = center + dir * sourceDist * vec2(1.0 / aspectRatio, 1.0);

                    vec2 duv = distortedUv;
                    float inBounds = step(0.0, duv.x) * step(duv.x, 1.0) * step(0.0, duv.y) * step(duv.y, 1.0);
                    duv = clamp(duv, 0.0, 1.0);
                    vec4 warpedColor = texture2D(tDiffuse, duv);
                    vec4 texColor = mix(baseColor, warpedColor, inBounds);

                    // Gemini already raymarches the horizon shadow; avoid painting a second black disk here.
                    float horizonAbsorb = 1.0 - smoothstep(radius * uHorizonAbsorbStart, radius * uHorizonAbsorbEnd, dist);
                    texColor.rgb *= (1.0 - uHorizonAbsorbAmount * horizonAbsorb);

                    float photonRing = 1.0 - smoothstep(radius * uRingStart, radius * uRingEnd, dist);
                    float ringDrive = pow(max(uCoreBrightness, 0.0), 0.62);
                    vec4 ringColor = vec4(1.0, 0.9, 0.7, 1.0) * photonRing * (uRingIntensity * ringDrive);

                    gl_FragColor = texColor + ringColor;
                }
            `
        };


        // --- 6. PIPELINE ---
        const composer = new EffectComposer(renderer);
        
        // Pass 1: Draw the heavily mathematical curved spacetime background
        const bgPass = new RenderPass(sceneRaymarch, orthoCamera);
        bgPass.clearColor = new THREE.Color(0x000000);
        bgPass.clearAlpha = 1.0;
        composer.addPass(bgPass);

        // Pass 2: Back layer (disk + particles)
        const backPass = new RenderPass(sceneBack, camera);
        backPass.clear = false;
        composer.addPass(backPass);

        // Pass 3: Lens only the back layer before front overlays
        const lensingPass = new ShaderPass(LensingShader);
        lensingPass.material.depthTest = false;
        lensingPass.material.depthWrite = false;
        composer.addPass(lensingPass);

        // Pass 4: Front layer (disk + particles)
        const frontPass = new RenderPass(sceneFront, camera);
        frontPass.clear = false;
        frontPass.clearDepth = true;
        composer.addPass(frontPass);

        // Pass 5: Cinematic Bloom
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.8, 0.5, 0.85);
        bloomPass.threshold = 0.2;
        composer.addPass(bloomPass);

        // --- 7. CONTROLS & RENDER LOOP ---
        const gui = new GUI({ title: 'Black Hole Physics' });
        const params = {
            spinSpeed: 0.05,
            lensStrength: 0.5,
            diskBrightness: 0.2,
            backDiskTuner: 1.0,
            frontDiskTuner: 1.0,
            particleBrightness: 3.0,
            showParticles: true,
            radius: 5.0,
            autoOrbit: false,
            expand: () => triggerExpansion()
        };
        gui.add(params, 'spinSpeed', 0.0, 2.0).name('Time Scale');
        gui.add(params, 'lensStrength', 0.0, 3.5).name('Lensing Strength');
        gui.add(params, 'diskBrightness', 0.0, 15.0).name('Core Brightness');
        gui.add(params, 'backDiskTuner', 0.0, 3.0, 0.01).name('Back Disk Tuner');
        gui.add(params, 'frontDiskTuner', 0.0, 3.0, 0.01).name('Front Disk Tuner');
        gui.add(params, 'particleBrightness', 0.0, 6.0).name('Gas Brightness');
        gui.add(params, 'showParticles').name('Show Particles').onChange((enabled) => {
            backParticles.visible = enabled;
            frontParticles.visible = enabled;
        });
        gui.add(params, 'radius', 1.0, 8.0).name('Black Hole Mass').listen();
        gui.add(params, 'autoOrbit').name('Auto Camera Orbit');
        gui.add(params, 'expand').name('Simulate Growth');

        const gasFolder = gui.addFolder('Gas Particles');
        gasFolder.add(particleParams, 'density', 0.0, 1.0, 0.001).name('Density');
        gasFolder.add(particleParams, 'sizeMul', 0.1, 4.0, 0.01).name('Size');
        gasFolder.add(particleParams, 'alpha', 0.0, 1.0, 0.001).name('Alpha');
        gasFolder.add(particleParams, 'softness', 2.0, 30.0, 0.1).name('Softness');
        gasFolder.add(particleParams, 'orbitMul', 0.0, 3.0, 0.01).name('Orbit Speed');
        gasFolder.add(particleParams, 'verticalScale', 0.0, 3.0, 0.01).name('Thickness');
        gasFolder.add(particleParams, 'jitterAmp', 0.0, 1.0, 0.001).name('Turbulence Amp');
        gasFolder.add(particleParams, 'jitterFreq', 0.0, 8.0, 0.01).name('Turbulence Freq');
        gasFolder.add(particleParams, 'coneStart', 5.0, 24.0, 0.1).name('Cone Start');
        gasFolder.add(particleParams, 'coneEnd', 8.0, 32.0, 0.1).name('Cone End');
        gasFolder.add(particleParams, 'coneMin', 0.0, 1.0, 0.001).name('Cone Min');
        gasFolder.add(particleParams, 'edgeStart', 8.0, 24.0, 0.1).name('Edge Start');
        gasFolder.add(particleParams, 'edgeEnd', 10.0, 32.0, 0.1).name('Edge End');
        gasFolder.add(particleParams, 'edgePow', 0.2, 4.0, 0.01).name('Edge Power');
        gasFolder.add(particleParams, 'beaming', 0.0, 2.0, 0.01).name('Beaming');
        gasFolder.add(particleParams, 'tempPow', 0.2, 3.0, 0.01).name('Temp Power');
        gasFolder.add(particleParams, 'coreGamma', 0.2, 1.2, 0.01).name('Core Response');
        gasFolder.add(particleParams, 'innerCutoff', -0.3, 1.5, 0.001).name('Inner Cutoff');
        gasFolder.add(particleParams, 'innerFadeStart', -0.3, 2.0, 0.001).name('Inner Fade Start');
        gasFolder.add(particleParams, 'innerFadeEnd', 0.0, 3.0, 0.001).name('Inner Fade End');
        gasFolder.addColor(particleParams, 'colorLow').name('Color Low');
        gasFolder.addColor(particleParams, 'colorMid').name('Color Mid');
        gasFolder.addColor(particleParams, 'colorHigh').name('Color High');
        gasFolder.close();

        const viewReadout = {
            yawDeg: 0.0,
            pitchDeg: 0.0,
            lookX: 0.0,
            lookY: 0.0,
            lookZ: -1.0
        };
        const viewFolder = gui.addFolder('View Direction');
        viewFolder.add(viewReadout, 'yawDeg').name('Yaw (deg)').listen();
        viewFolder.add(viewReadout, 'pitchDeg').name('Pitch (deg)').listen();
        viewFolder.add(viewReadout, 'lookX').name('Look X').listen();
        viewFolder.add(viewReadout, 'lookY').name('Look Y').listen();
        viewFolder.add(viewReadout, 'lookZ').name('Look Z').listen();
        viewFolder.close();

        const debugParams = {
            raymarchUseInverseMassCoupling: true,
            raymarchCouplingScale: 2.5,
            raymarchStrengthMultiplier: 1.0,
            raymarchStrengthMax: 0.65,
            raymarchGravityK: 1.5,
            raymarchHorizonHit: 0.98,
            raymarchEscapeRadius: 150.0,
            raymarchMaxSteps: 600,
            raymarchStepScale: 0.04,
            raymarchUseEquatorClamp: false,
            raymarchEquatorBand: 0.0,
            raymarchEquatorRadius: 30.0,
            raymarchEquatorStepMin: 0.015,
            raymarchEquatorStepScale: 0.3,
            raymarchNearHorizonFallback: 1.03,
            raymarchDebugTermination: false,
            wrapUseMassCoupling: true,
            wrapCouplingScale: 2.5,
            wrapStrengthMultiplier: 1.0,
            wrapStrengthMax: 3.5,
            lensRadiusScale: 1.0,
            lensCenterPreserve: 0.98,
            lensViewDamp: 0.85,
            lensHorizonAbsorbStart: 0.90,
            lensHorizonAbsorbEnd: 0.98,
            lensHorizonAbsorbAmount: 0.0,
            lensRingStart: 0.98,
            lensRingEnd: 1.05,
            lensRingIntensity: 1.5,
            frontCoreMaskScale: 0.98,
            showRaymarchBackground: true,
            showBackLayer: true,
            showLensingPass: true,
            showFrontLayer: true,
            showBloomPass: true,
            resolvedRaymarchStrength: 0.0,
            resolvedWrapStrength: 0.0
        };

        const debugFolder = gui.addFolder('Debug / Advanced');
        debugFolder.add(debugParams, 'raymarchUseInverseMassCoupling').name('Raymarch Couple Inverse Mass');
        debugFolder.add(debugParams, 'raymarchCouplingScale', 0.0, 12.0, 0.01).name('Raymarch Coupling Scale');
        debugFolder.add(debugParams, 'raymarchStrengthMultiplier', 0.0, 6.0, 0.01).name('Raymarch Strength Mult');
        debugFolder.add(debugParams, 'raymarchStrengthMax', 0.0, 6.0, 0.01).name('Raymarch Strength Max');
        debugFolder.add(debugParams, 'raymarchGravityK', 0.0, 4.0, 0.01).name('Raymarch Gravity K');
        debugFolder.add(debugParams, 'raymarchHorizonHit', 0.0, 1.20, 0.001).name('Raymarch Horizon Hit');
        debugFolder.add(debugParams, 'raymarchEscapeRadius', 20.0, 400.0, 1.0).name('Raymarch Escape Radius');
        debugFolder.add(debugParams, 'raymarchMaxSteps', 16.0, 1200.0, 1.0).name('Raymarch Max Steps');
        debugFolder.add(debugParams, 'raymarchStepScale', 0.001, 0.2, 0.001).name('Raymarch Step Scale');
        debugFolder.add(debugParams, 'raymarchUseEquatorClamp').name('Raymarch Equator Clamp');
        debugFolder.add(debugParams, 'raymarchEquatorBand', 0.0, 8.0, 0.01).name('Raymarch Eq Band');
        debugFolder.add(debugParams, 'raymarchEquatorRadius', 0.0, 120.0, 0.1).name('Raymarch Eq Radius');
        debugFolder.add(debugParams, 'raymarchEquatorStepMin', 0.0, 0.2, 0.001).name('Raymarch Eq Step Min');
        debugFolder.add(debugParams, 'raymarchEquatorStepScale', 0.0, 2.0, 0.001).name('Raymarch Eq Step Scale');
        debugFolder.add(debugParams, 'raymarchNearHorizonFallback', 1.0, 2.0, 0.001).name('Raymarch Near-Horizon Fallback');
        debugFolder.add(debugParams, 'raymarchDebugTermination').name('Raymarch Debug Termination');
        debugFolder.add(debugParams, 'wrapUseMassCoupling').name('Wrap Couple Mass');
        debugFolder.add(debugParams, 'wrapCouplingScale', 0.0, 12.0, 0.01).name('Wrap Coupling Scale');
        debugFolder.add(debugParams, 'wrapStrengthMultiplier', 0.0, 6.0, 0.01).name('Wrap Strength Mult');
        debugFolder.add(debugParams, 'wrapStrengthMax', 0.0, 8.0, 0.01).name('Wrap Strength Max');
        debugFolder.add(debugParams, 'lensRadiusScale', 0.0, 2.5, 0.01).name('Lens Radius Scale');
        debugFolder.add(debugParams, 'lensCenterPreserve', 0.0, 1.20, 0.001).name('Lens Center Preserve');
        debugFolder.add(debugParams, 'lensViewDamp', 0.0, 1.5, 0.01).name('Lens View Damp');
        debugFolder.add(debugParams, 'lensHorizonAbsorbStart', 0.0, 1.50, 0.001).name('Lens Horizon Start');
        debugFolder.add(debugParams, 'lensHorizonAbsorbEnd', 0.0, 1.80, 0.001).name('Lens Horizon End');
        debugFolder.add(debugParams, 'lensHorizonAbsorbAmount', 0.0, 1.0, 0.01).name('Lens Horizon Darken');
        debugFolder.add(debugParams, 'lensRingStart', 0.0, 1.30, 0.001).name('Lens Ring Start');
        debugFolder.add(debugParams, 'lensRingEnd', 0.0, 1.60, 0.001).name('Lens Ring End');
        debugFolder.add(debugParams, 'lensRingIntensity', 0.0, 5.0, 0.01).name('Lens Ring Intensity');
        debugFolder.add(debugParams, 'frontCoreMaskScale', 0.7, 1.3, 0.001).name('Front Core Mask');
        debugFolder.add(debugParams, 'showRaymarchBackground').name('Show Raymarch Bg');
        debugFolder.add(debugParams, 'showBackLayer').name('Show Back Layer');
        debugFolder.add(debugParams, 'showLensingPass').name('Show Lensing Pass');
        debugFolder.add(debugParams, 'showFrontLayer').name('Show Front Layer');
        debugFolder.add(debugParams, 'showBloomPass').name('Show Bloom');
        debugFolder.add(debugParams, 'resolvedRaymarchStrength').name('Resolved Raymarch').listen();
        debugFolder.add(debugParams, 'resolvedWrapStrength').name('Resolved Wrap').listen();
        debugFolder.close();

        let isExpanding = false;
        let expansionTime = 0;
        let currentScale = 1.0;

        function triggerExpansion() {
            if(isExpanding) return;
            isExpanding = true;
            expansionTime = 0;
            currentScale = 0.1;
        }

        const clock = new THREE.Clock();
        const cameraMat = new THREE.Matrix4();
        const bhWorldPos = new THREE.Vector3();
        const lookDir = new THREE.Vector3();
        const drawBufferSize = new THREE.Vector2();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            if (params.autoOrbit) {
                // Slowly pan the camera around the black hole automatically
                camera.position.x = Math.cos(time * 0.1) * 35;
                camera.position.z = Math.sin(time * 0.1) * 35;
                camera.lookAt(0, 0, 0);
            }
            controls.update();
            camera.getWorldDirection(lookDir);
            const yaw = Math.atan2(lookDir.x, lookDir.z);
            const pitch = Math.asin(THREE.MathUtils.clamp(lookDir.y, -1.0, 1.0));
            viewReadout.yawDeg = Number((THREE.MathUtils.radToDeg(yaw)).toFixed(2));
            viewReadout.pitchDeg = Number((THREE.MathUtils.radToDeg(pitch)).toFixed(2));
            viewReadout.lookX = Number((lookDir.x).toFixed(3));
            viewReadout.lookY = Number((lookDir.y).toFixed(3));
            viewReadout.lookZ = Number((lookDir.z).toFixed(3));

            cameraMat.extractRotation(camera.matrixWorld);
            
            raymarchMat.uniforms.uCameraPos.value.copy(camera.position);
            raymarchMat.uniforms.uCameraMatrix.value.copy(cameraMat);
            raymarchMat.uniforms.uTime.value = time;
            raymarchMat.uniforms.uSpinSpeed.value = params.spinSpeed;
            raymarchMat.uniforms.uDiskBrightness.value = params.diskBrightness;
            raymarchMat.uniforms.uGravityK.value = debugParams.raymarchGravityK;
            raymarchMat.uniforms.uHorizonHit.value = debugParams.raymarchHorizonHit;
            raymarchMat.uniforms.uEscapeRadius.value = debugParams.raymarchEscapeRadius;
            raymarchMat.uniforms.uMaxSteps.value = Math.floor(debugParams.raymarchMaxSteps);
            raymarchMat.uniforms.uStepScale.value = debugParams.raymarchStepScale;
            raymarchMat.uniforms.uEquatorClampEnabled.value = debugParams.raymarchUseEquatorClamp ? 1.0 : 0.0;
            raymarchMat.uniforms.uEquatorBand.value = debugParams.raymarchEquatorBand;
            raymarchMat.uniforms.uEquatorRadius.value = debugParams.raymarchEquatorRadius;
            raymarchMat.uniforms.uEquatorStepMin.value = debugParams.raymarchEquatorStepMin;
            raymarchMat.uniforms.uEquatorStepScale.value = debugParams.raymarchEquatorStepScale;
            raymarchMat.uniforms.uNearHorizonFallback.value = debugParams.raymarchNearHorizonFallback;
            raymarchMat.uniforms.uDebugTerminationMode.value = debugParams.raymarchDebugTermination ? 1.0 : 0.0;
            // Keep raymarch shadow stable: high lens slider should increase wrap, not inflate a giant black orb.
            const raymarchMassFactor = debugParams.raymarchUseInverseMassCoupling
                ? (debugParams.raymarchCouplingScale / Math.max(params.radius, 0.5))
                : 1.0;
            const raymarchStrength = THREE.MathUtils.clamp(
                params.lensStrength * debugParams.raymarchStrengthMultiplier * raymarchMassFactor,
                0.0,
                debugParams.raymarchStrengthMax
            );
            raymarchMat.uniforms.uLensStrength.value = raymarchStrength;
            debugParams.resolvedRaymarchStrength = raymarchStrength;
            
            sharedUniforms.uCameraPos.value.copy(camera.position);
            sharedUniforms.uTime.value = time;
            sharedUniforms.uSpinSpeed.value = params.spinSpeed;
            sharedUniforms.uCoreBrightness.value = params.diskBrightness;
            plasmaMatBack.uniforms.uLayerAlpha.value = DISK_LAYER_ALPHA_BASE * params.backDiskTuner;
            plasmaMatFront.uniforms.uLayerAlpha.value = DISK_LAYER_ALPHA_BASE * params.frontDiskTuner;
            particleGeo.setDrawRange(0, Math.floor(particleCount * THREE.MathUtils.clamp(particleParams.density, 0.0, 1.0)));
            pMatBack.uniforms.uParticleBrightness.value = params.particleBrightness;
            pMatFront.uniforms.uParticleBrightness.value = params.particleBrightness;
            pMatBack.uniforms.uInnerCutoff.value = particleParams.innerCutoff;
            pMatFront.uniforms.uInnerCutoff.value = particleParams.innerCutoff;
            pMatBack.uniforms.uInnerFadeStart.value = particleParams.innerFadeStart;
            pMatFront.uniforms.uInnerFadeStart.value = particleParams.innerFadeStart;
            pMatBack.uniforms.uInnerFadeEnd.value = particleParams.innerFadeEnd;
            pMatFront.uniforms.uInnerFadeEnd.value = particleParams.innerFadeEnd;
            pMatBack.uniforms.uParticleAlpha.value = particleParams.alpha;
            pMatFront.uniforms.uParticleAlpha.value = particleParams.alpha;
            pMatBack.uniforms.uParticleSoftness.value = particleParams.softness;
            pMatFront.uniforms.uParticleSoftness.value = particleParams.softness;
            pMatBack.uniforms.uParticleEdgeStart.value = particleParams.edgeStart;
            pMatFront.uniforms.uParticleEdgeStart.value = particleParams.edgeStart;
            pMatBack.uniforms.uParticleEdgeEnd.value = particleParams.edgeEnd;
            pMatFront.uniforms.uParticleEdgeEnd.value = particleParams.edgeEnd;
            pMatBack.uniforms.uParticleEdgePow.value = particleParams.edgePow;
            pMatFront.uniforms.uParticleEdgePow.value = particleParams.edgePow;
            pMatBack.uniforms.uParticleBeaming.value = particleParams.beaming;
            pMatFront.uniforms.uParticleBeaming.value = particleParams.beaming;
            pMatBack.uniforms.uParticleTempPow.value = particleParams.tempPow;
            pMatFront.uniforms.uParticleTempPow.value = particleParams.tempPow;
            pMatBack.uniforms.uParticleCoreGamma.value = particleParams.coreGamma;
            pMatFront.uniforms.uParticleCoreGamma.value = particleParams.coreGamma;
            pMatBack.uniforms.uParticleOrbitMul.value = particleParams.orbitMul;
            pMatFront.uniforms.uParticleOrbitMul.value = particleParams.orbitMul;
            pMatBack.uniforms.uParticleVerticalScale.value = particleParams.verticalScale;
            pMatFront.uniforms.uParticleVerticalScale.value = particleParams.verticalScale;
            pMatBack.uniforms.uParticleJitterAmp.value = particleParams.jitterAmp;
            pMatFront.uniforms.uParticleJitterAmp.value = particleParams.jitterAmp;
            pMatBack.uniforms.uParticleJitterFreq.value = particleParams.jitterFreq;
            pMatFront.uniforms.uParticleJitterFreq.value = particleParams.jitterFreq;
            pMatBack.uniforms.uParticleSizeMul.value = particleParams.sizeMul;
            pMatFront.uniforms.uParticleSizeMul.value = particleParams.sizeMul;
            pMatBack.uniforms.uParticleConeStart.value = particleParams.coneStart;
            pMatFront.uniforms.uParticleConeStart.value = particleParams.coneStart;
            pMatBack.uniforms.uParticleConeEnd.value = particleParams.coneEnd;
            pMatFront.uniforms.uParticleConeEnd.value = particleParams.coneEnd;
            pMatBack.uniforms.uParticleConeMin.value = particleParams.coneMin;
            pMatFront.uniforms.uParticleConeMin.value = particleParams.coneMin;
            pMatBack.uniforms.uParticleColorLow.value.set(particleParams.colorLow);
            pMatFront.uniforms.uParticleColorLow.value.set(particleParams.colorLow);
            pMatBack.uniforms.uParticleColorMid.value.set(particleParams.colorMid);
            pMatFront.uniforms.uParticleColorMid.value.set(particleParams.colorMid);
            pMatBack.uniforms.uParticleColorHigh.value.set(particleParams.colorHigh);
            pMatFront.uniforms.uParticleColorHigh.value.set(particleParams.colorHigh);
            lensingPass.uniforms.uCameraPos.value.copy(camera.position);
            lensingPass.uniforms.uCenterPreserve.value = debugParams.lensCenterPreserve;
            lensingPass.uniforms.uViewDamp.value = debugParams.lensViewDamp;
            lensingPass.uniforms.uHorizonAbsorbStart.value = debugParams.lensHorizonAbsorbStart;
            lensingPass.uniforms.uHorizonAbsorbEnd.value = debugParams.lensHorizonAbsorbEnd;
            lensingPass.uniforms.uHorizonAbsorbAmount.value = debugParams.lensHorizonAbsorbAmount;
            lensingPass.uniforms.uRingStart.value = debugParams.lensRingStart;
            lensingPass.uniforms.uRingEnd.value = debugParams.lensRingEnd;
            lensingPass.uniforms.uRingIntensity.value = debugParams.lensRingIntensity;
            // Old-style wrap coupling with full debug controls.
            const wrapMassFactor = debugParams.wrapUseMassCoupling
                ? (params.radius / Math.max(debugParams.wrapCouplingScale, 0.1))
                : 1.0;
            const wrapStrength = THREE.MathUtils.clamp(
                params.lensStrength * debugParams.wrapStrengthMultiplier * wrapMassFactor,
                0.0,
                debugParams.wrapStrengthMax
            );
            lensingPass.uniforms.strength.value = wrapStrength;
            debugParams.resolvedWrapStrength = wrapStrength;
            lensingPass.uniforms.uCoreBrightness.value = params.diskBrightness;

            if (isExpanding) {
                expansionTime += delta;
                const progress = Math.min(expansionTime / 3.0, 1.0);
                const easeOut = 1 - Math.pow(1 - progress, 3);
                currentScale = 0.1 + (easeOut * 0.9); 
                params.radius = 5.0 * currentScale; // Grow up to mass/size 5.0
                if (progress >= 1.0) isExpanding = false;
            }

            raymarchMat.uniforms.uRadiusLimit.value = params.radius;
            sharedUniforms.uRadiusLimit.value = params.radius;
            
            bhWorldPos.set(0, 0, 0).project(camera);
            lensingPass.uniforms.center.value.set((bhWorldPos.x + 1) * 0.5, (bhWorldPos.y + 1) * 0.5);

            const dist = camera.position.length();
            const vFOV = THREE.MathUtils.degToRad(camera.fov);
            const viewHeight = 2 * Math.tan(vFOV * 0.5) * dist;
            lensingPass.uniforms.radius.value = (params.radius / Math.max(viewHeight, 0.0001)) * debugParams.lensRadiusScale;
            sharedUniforms.uLensCenter.value.copy(lensingPass.uniforms.center.value);
            sharedUniforms.uLensRadius.value = lensingPass.uniforms.radius.value;
            sharedUniforms.uAspectRatio.value = lensingPass.uniforms.aspectRatio.value;
            renderer.getDrawingBufferSize(drawBufferSize);
            sharedUniforms.uViewport.value.copy(drawBufferSize);
            sharedUniforms.uFrontCoreMaskScale.value = debugParams.frontCoreMaskScale;
            bgPass.enabled = debugParams.showRaymarchBackground;
            backPass.enabled = debugParams.showBackLayer;
            lensingPass.enabled = debugParams.showLensingPass;
            frontPass.enabled = debugParams.showFrontLayer;
            bloomPass.enabled = debugParams.showBloomPass;

            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            raymarchMat.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
            lensingPass.uniforms.aspectRatio.value = window.innerWidth / window.innerHeight;
            sharedUniforms.uAspectRatio.value = window.innerWidth / window.innerHeight;
            renderer.getDrawingBufferSize(drawBufferSize);
            sharedUniforms.uViewport.value.copy(drawBufferSize);
        });

        animate();
    </script>
</body>
</html>
